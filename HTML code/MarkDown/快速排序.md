# QX算法学习笔记XQ

# 快速排序

1.确定分界点去q[1] 	q[(l+1)/2]	q[l] (确定分界点随机)

2.调整区间（设x）小于等于x在区间左，大于等于x在区间右，x不一定在区间中间（因为不按大小排序，好比两个框，只是进行二类筛选，两种情况）

3.递归处理左右两框（<=x || >=x）{

​	(1)暴力方法 //2.

```c
	int a[];
	int b[];
	int k=1,j=1;
	for(int i=1;i<=l;i++){
		if(q[i]<=x)a[j]=q[i],j++;
		if(q[i]>=x)b[k]=q[i],k++;
	}
	j=1,k=1;
	for(int i=1;i<=l;i++){
		if(i<=j)q[i]=a[j],j++;
		else q[i]=b[k],k++;
	}
```



​	(2)下标swap

```c++
#include<iotstream>
using namespace std;

const int N = 1e6 + 10;

int n;
int q[N];

void quick_sort(int q[],int l,int r){ 
	if(l>=r)return;
	
	int x = q[l] , i=l-1 , j=r+1;
	while(i<j){
	 	do{ i++ };while(q[i]<x);
	 	do{ j-- };while(q[j]>x);
	 	if(i<j) swap(q[i],q[j]); //swap函数交换
	}
	quick_sort(q,l,j); //防止越界，进入死循环（l，j）
	qucik_sort(q,j+1,r);
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%d",&q[i]);
    quick_sort(q,0,n-1);
    
    return 0;
}
```

}

#  查找第k个数

1.找到分界点x( q[l]	q[(l+r)/2]	q[r] )；

2.划分两区left（x>=) ,right (x<=)

3.递归排序（k<=left区个数（k）递归左区 ，k>right区个数递归右区(k-L) )

4.时间复杂度O（2n）（n+n/2+n/4+...)

```c++
#include<bits/stdc++.h>
using namespace std;
int x[5000005],k;
void qsort(int l,int r)
{
	int i=l,j=r,mid=x[(l+r)/2];
	do
	{
		while(x[j]>mid)
			j--;
		while(x[i]<mid)
			i++;
		if(i<=j)
		{
			swap(x[i],x[j]);
			i++;
			j--;
		}
	}
	while(i<=j);
	//快排后数组被划分为三块： l<=j<=i<=r
	if(k<=j) qsort(l,j);//在左区间只需要搜左区间
	else if(i<=k) qsort(i,r);//在右区间只需要搜右区间
	else //如果在中间区间直接输出
	{
		printf("%d",x[j+1]);
		exit(0);
	}
}
int main()
{
	int n;
	scanf("%d%d",&n,&k);
	for(int i=0;i<n;i++)
		scanf("%d",&x[i]);
	qsort(0,n-1);
}
```

# 归并排序（重点）

1.以数组中间部分分左右两部分。

2.递归排序left，right

3.归并———***合二为一***（双指针）

![](C:\Users\30959\Pictures\1.png)

```c++
#include<iostream>
uisng namespace std;
const int N=100010;
int n;
int q[N],t[N];

void mega_sort(int q[],int l,int r){
    if(l==r)return;
    int mid= l + r >> 1;
    mega_sort(q,l,mid),mega_sort(q,mid,r);
    
    int k=0,i=l,j=mid+1;
    while(i<=mid && j<=r){
        if(q[i]<q[j])t[k++]=q[i++]; //如上图
        else t[k++]=q[j++];
    }
    while(i<=mid)t[k++]=q[i++]; //如果前面没移完，把剩下的数接到后边
    while(j<=r)t[k++]=q[j++];
     
    for(i=l,j=0;i<=r;i++,j++)q[i]=t[j]; //复制回原数组
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%d",&q[i]);
    mega(q,0,n-1);
    for(int i=0;i<n;i++)printf("%d ",q[i]);
    
	return 0;
}
```



# 逆序对的数量

#### 递归分至两个数（以下圈圈代表），拆至最小单位2。

#### 边算边排把算过的数列排序成有序数列实现下图操作

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241021210528194.png)

实现代码

```c++
#include<iostream>
using namespace std;
const int N=10e6;
int a[N],t[N];
typedef long long ll;

ll pp(int l,int r){
    if(l>=r)return 0;
    int mid= (l+r) >> 1;
    ll res=pp(l,mid)+pp(mid+1,r);

    int k=0,i=l,j=mid+1;
    while(i<=mid && j<=r){
        if(a[i]<=a[j])t[k++]=a[i++];
        else {
            t[k++]=a[j++];
            res+=mid-i+1;
        }
    }
    while(i<=mid)t[k++]=a[i++];
    while(j<=r)t[k++]=a[j++];

    for(i=l,j=0;i<=r;i++,j++)a[i]=t[j];
    return res;
}

int main()
{
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%d",&a[i]);

    cout << pp(0,n-1);

    return 0;
}
```

![](D:\QQ文件\IMG_20241024_205504.jpg)

# 二分

## 整数二分

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241021214732686.png)

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241021214810696.png)

### 代码

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241022100610228.png)



# 数的三次方根

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241022103834078.png)



# 高精度

## 实质上就是把每一位数字存入数组中实现超大位数运算

### 乘法

实现代码（个人想法）

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N=10e6+10;
int q[N];
int p[N];
int l[N];

int main()
{
    string a;
    string b;
    cin >> a;
    cin >> b;
    int k=0;
    for(int i=a.size()-1;i>=0;i--)q[k]=a[i]-'0',k++; // 注意size要减1，否则会往前存一位，导致下标0处会是一些默认的稀奇古怪的值
    k=0;
    for(int i=b.size()-1;i>=0;i--)p[k]=b[i]-'0',k++;
    for(int i=0;i<a.size();i++){
        for(int j=0;j<b.size();j++){
            l[i+j]+=q[i]*p[j];
        }
    }

    for(int i=0;i<a.size()+b.size();i++){
        if(l[i]>=10){
            l[i+1]+=l[i]/10;
            l[i]%=10;
        }
        else continue;
    }

    int t=0;
    for(int i=a.size()+b.size()-1;i>=0;i--){
        if((a[0]=='0' && a.size()==1) || (b[0]=='0' && b.size()==1)){
            cout << "0";
            break;
        }
        if(l[i]==0 && t==0)continue;
        else if(l[i]!=0 && t==0)t=1;
        if(t==1)cout << l[i];
    }

    return 0;
}
```

### 除法

实现代码

```c++
#include<iostream>
using namespace std;

vector<int> pp(vector<int> &A,int b,int &r){
	vector<int> C;
    for(int i=A.size()-1;i>=0;i--){
        r=r*10 + A[i];
        C.push_back(r/b);
        r%=b
    }
    
    reverse(C.begin,C.end()); //反转C数组
    while(C.size() > 1 && C.back()==0) C.pop_back();
    
    return C;
}

int main()
{
	string a;
	int b;
	
	cin >> a >> b;
	
	vector<int>A;
	for(int i=0;i<a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	
	int r=0; //余数
	auto C=pp(A,b,r);
	
	for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
	cout << endl << r;
	
	return 0;
}
```

# 前缀和

## 前i项的和（公式而已）

```c++
#include<iostream>
using namespace std;
const int N=10e6+10;
int a[N];
int s[N];


int main()
{
    int n,m;
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        cin >> a[i];
        s[i]=s[i-1]+a[i];
    }

    int l1,l2;
    for(int i=0;i<m;i++){
        cin >> l1 >> l2;
        cout << s[l2]-s[l1-1];
    }

    return 0;
}
```

## 求子矩阵和

题如下

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241023195907627.png)

题解代码

```c++
#include<iostream>
using namespace std;
const int N=1010;
int n,m,q;
int a[N][N];

int main()
{
	scnaf("%d %d %d",&n,&m,&q);
	for(inti=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s[i][j]=s[i-1][j]+s[i][j-1]+s[i-1][j-1]+a[i][j];	//求前缀和
		}
	}

	while(q--){
		int x1,x2,y1,y2;
        scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
        printf("%d\n",s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]); //算子矩阵的和
	}

	return 0;
}
```

# 差分

### 题目

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241023204511661.png)

### 构造a数组的对体(利用前缀和)

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241023210604650.png)

### 代码实现

```c++
#include<iostream>
using namespace std;
const int N=10e6+10;
int a[N],b[N];
int n,m;

void pp(int l,int r,int c){
    b[l]+=c;
    b[r+1]-=c;
}

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<n;i++)scanf("%d",&a[i]);

    for(int i=0;i<n;i++)pp(i,i,a[i]);

    while(m--){
        int l,r,c;
        scanf("%d %d %d",&l,&r,&c);
        pp(l,r,c);
    }

    for(int i=1;i<=n;i++)b[i]+=b[i-1];

    for(int i=1;i<=n;i++)cout << b[i] << ' ';

    return 0;
}
```

#### 逻辑顺序(个人理解)

------

a1 a2 a3 a4 ... an               (L:1,R:3,+1)
b1=a1		       b1=a1                   b1=a1
b2=a2-a1		 b2=a2-a1+1	   b2=a2+1	
b3=a3-a2		 b3=a3-a2		b3=a3+1
b4=a4-a3		 b4=a3-a2-1		b4=a4
....				 ....				....
bn=an-a(n-1)		 bn=an-a(n-1)	bn=an-a(n-1)

------



# 离散化

### 例题

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 n 次操作，每次操作将某一位置 xx 上的数加 cc。

接下来，进行 mm 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r][l,r] 之间的所有数的和。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含两个整数 xx 和 cc。

再接下来 mm 行，每行包含两个整数 l 和 r。

#### 输出格式

共 mm 行，每行输出一个询问中所求的区间内数字和。

#### 数据范围

−109≤x≤109−109≤x≤109,
1≤n,m≤1051≤n,m≤105,
−109≤l≤r≤109−109≤l≤r≤109,
−10000≤c≤10000−10000≤c≤10000

#### 输入样例：

```
3 3
1 2
3 6
7 5
1 3
4 6
7 8
```

#### 输出样例：

```
8
0
5
```



## 问题所在

### 在无限数轴上只有稀疏的数从头到尾遍历效率过低，但通过映射数轴上的数进一个较短有序的数组实现优化

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int,int>p;
const int N = 300000;

vector<p>add;     //保存真实下标和值(两个值)
vector<int>alls;    //询问下标和真实值下标放在一起，之后进行排列
vector<p>q;       //保存查询端点(两个值)
int a[N];       //真实值映射出的新数组
int s[N];       //a的前缀和

int find(int x){
    int l=1,r=alls.size();
    while(l<r){             //通过二分查找
        int mid=(l+r)>>1;   //将真实下标与询问和真实下标的位置（已去重复位置）进行比大小，找出对应映射下表
        if(alls[mid]>=x)r=mid;  //alls里装着原有的离散位置
        else l=mid+1;
    }
    return l; //返回的及对应的映射位置。前缀和从下标1开始，不用再考虑边界问题。
}

int main()
{
    int n,m;
    cin >> n >> m;
    for(int i=0;i<n;i++){
        int x,c;
        cin >> x >> c;
        add.push_back({x,c});
        alls.push_back(x);
    }
    for(int i=0;i<m;i++){
        int l,r;
        cin >> l >> r;
        q.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }

    sort(alls.begin(),alls.end());		//位置下标排序
    alls.erase(unique(alls.begin(),alls.end()),alls.end());		//除去重复位置下标

    for(int i=0;i<add.size();i++){
        int x=find(add[i].first);     //传入真实值的下标，找出映射出的下标
        a[x]+=add[i].second;            //放入真实值（add先前保存）
    }

    for(int i=1;i<=alls.size();i++)s[i]=s[i-1]+a[i];    //前缀和处理

    for(int i=0;i<q.size();i++){
        int l=find(q[i].first);		//将询问下标映射为新数组的下标
        int r=find(q[i].second);
        cout << s[r]-s[l-1] << endl;
    }

    return 0;
}
```



# 单链表

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241101221824859.png)

### 个人理解：通俗来讲就是把数轴上空的位置忽略，把有存在值的用数组存在一起（两个部分：值，下个值的指向方向）

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241102182617324.png)



#### 

```c++
#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int data;
    struct ListNode *next;
};

struct ListNode *readlist();
struct ListNode *deletem( struct ListNode *L, int m );
void printlist( struct ListNode *L )
{
     struct ListNode *p = L;
     while (p) {
           printf("%d ", p->data);
           p = p->next;
     }
     printf("\n");
}

int main()
{
    int m;
    struct ListNode *L = readlist();
    scanf("%d", &m);
    L = deletem(L, m);
    printlist(L);

    return 0;
}

struct ListNode *readlist()             // 读取链表
{
    struct ListNode *head,*p1,*p2;      // 定义头结点和两个临时指针变量
    int n=0;                            // 定义节点数量
    head = NULL;                        // 初始化头结点为空指针
    p1 = p2 = (struct ListNode*)malloc(sizeof(struct ListNode));  // 开辟新空间
    scanf("%d",&p1->data);              // 从键盘上读入第一个节点的数据
    while(p1->data!=-1)                 // 如果当前节点不是最后一个节点
    {
        n++;                            // 记录节点个数
        if(n==1)                        // 如果是头节点
            head = p1;                  // 将当前节点作为头结点
        else
            p2->next = p1;              // 将前一个节点指针指向当前节点
        p2 = p1;                        // 将 p1 赋值给 p2，以便在下一次循环中使用
        p1 = (struct ListNode*)malloc(sizeof(struct ListNode));   // 为下一节点开辟新空间
        scanf("%d",&p1->data);          // 读入下一个节点的数据
    }
    p2->next = NULL;                    // 最后一个节点指向 NULL
    return head;                        // 返回头结点指针
}
struct ListNode *deletem( struct ListNode *L, int m )    // 删除指定元素
{
    struct ListNode *p1,*p2;            // 定义两个指针变量
    p1 = L;                             // 将 L（链表的头结点）赋值给 p1
    while(p1!=NULL)                     // 循环遍历链表
    {
        if(p1->data==m)                 // 如果当前节点存储的数据等于待删除的数 m
        {
            if(p1==L)                   // 如果当前节点是头节点
                L = p1->next;           // 将头指针指向当前节点的下一个节点，即删除头节点
            else
                p2->next = p1->next;    // 将前一个节点的指针指向当前节点的下一个节点，即删除中间节点或尾节点
        }
        else
        {
            p2 = p1;                    // 将 p1 赋值给 p2，以便在下一次循环中使用
        }
        p1 = p1->next;                  // 将 p1 指向下一个节点
    }
    return L;                           // 返回操作后的链表
}
```

------



## 链表逆置

![image-20241220173446587](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241220173446587.png)



```C
struct ListNode *reverse( struct ListNode *head ){
    struct *p1,*p2,*t ;
    p1 = head;
    while(p1){
        t = p1->next;
        p1->next = p2;
        //往前移动 p1 =a1(head) , p2 = NULL --> p1 = a2 , p2 = a1;
        p2 = p1;
        p1 = t;
    }
    return p2
}
```



# 双链表

### 比单链表多存了个指针（指向后面）两个指针分别指向左右两侧

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241102192746724.png)

```c++
#include<iostream>
using namespace std;
const int N = 1e5+10;

struct pp{
    int l;
    int r;
    int num;
}pp[N];
//p为顺序下标
void add(int k,int p){
    pp[p].l=pp[pp[k].r].l;
    pp[pp[k].r].l=p;
    pp[p].r=pp[k].r;
    pp[k].r=p;
}
void kill(int k){
    if(pp[k].l==-1 && pp[k].r==-1)return;
    pp[pp[k].l].r=pp[k].r;
    pp[pp[k].r].l=pp[k].l;
    pp[k].r=-1;
    pp[k].l=-1;
}

int main()
{
    int n;
    cin >> n;
    pp[0].r=2; //头
    pp[1].l=2; //尾
    pp[2].num=1;
    pp[2].l=0;
    pp[2].r=1;
    for(int i=3;i<=n+1;i++){
        int k,p;
        pp[i].num=i-1;
        cin >> k >> p;
        if(p==0)add(pp[k+1].l,i); // 该节点上一个指向的数，所以是l
        else add(k+1,i);
    }
    int m;
    cin >> m;
    for(int i=0;i<m;i++){
        int k;
        cin >> k;
        kill(k+1);
    }
//尾的下标是1，当下标等于尾的下标时停止
    for(int i=pp[0].r;i!=1;i=pp[i].r){
        cout << pp[i].num << ' ';
    }

    return 0;
}
```



# 栈

## 一大特点：后进先出（如同网站网页退回顺序）

[【队列、数组队列、链表队列、完整代码动画解析，数据结构与算法】https://www.bilibili.com/video/BV12C411G7LR?vd_source=d822d177348c71c285e07dfb31013776](清晰的动画讲解)

```c++
#include<iostream>
#include<vector>
using namespace std;
typedef int p;

vector<p>a;

int main(){
    int n;
    cin >> n;
    a.push_back(-1);//作为栈的底，不插入数
    for(int i=0;i<n;i++){
        string b;
        int x;
        cin >> b;
        if(b=="push"){//往栈顶插入一个数
            cin >> x;
            a.push_back(x);
        }
        else if(b=="pop"){//弹出栈顶的元素
            a.pop_back();
        }
        else if(b=="empty"){//检查栈堆是否为空
            if(a.size()==1)cout << "YES" << endl;
            else cout << "NO" << endl;
        }
        else if(b=="query"){//查看栈顶元素（数）
            cout << a.back() << endl;
        }
    }

    return 0;
}
```



# 表达式求值

### 利用了栈的思想来进行运算（符号运算优先度）

```c++
#include<iostream>
#include<algorithm>
#include<stack>
#include<unordered_map>
using namespace std;

//双栈
stack<int>num; //存数字	
stack<char>op; //存运算符

//求值函数,使用末尾的运算符操作末尾的两个数
void eval()
{
    auto b = num.top(); num.pop();//第二个操作数
    auto a = num.top(); num.pop();//第一个操作数
    auto c = op.top(); op.pop();  //运算符

    int x;                        //结果计算(注意顺序)
    if (c == '+')x = a + b;
    else if (c == '-')x = a - b;
    else if (c == '*')x = a * b;
    else x = a / b;
    num.push(x);                  //结果入栈
}

int main()
{
    //优先级表
    unordered_map<char, int>pr{ {'+',1},{'-',1},{'*',2},{'/',2} };

    //读入表达式
    string str;
    cin >> str;

    //从前往后扫描表达式
    for (int i = 0; i < str.size(); i++)
    {
        auto c = str[i];
        //扫描到数字,使用双指针法一直读入
        if (isdigit(c))
        {
            //j表示扫描到数字的指针
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j++] - '0';
            //更新i指针
            i = j - 1;
            //数字入栈
            num.push(x);
        }
        //左括号直接入栈
        else if (c == '(')op.push(c);
        //右括号出现,从右往左计算栈中数据,直到遇见左括号
        else if (c == ')')
        {
            //不断使用eval函数对末尾数字运算
            while (op.top() != '(')eval();
            //弹出左括号
            op.pop();
        }
        //扫描到运算符
        else
        {
            //如果栈顶运算符优先级较高,先操作栈顶元素再入栈
            while (op.size() && pr[op.top()] >= pr[c])eval();
            //如果栈顶运算符优先级较低,直接入栈
            op.push(c);
        }
    }
    //把没有操作完的运算符从右往左操作一遍
    while (op.size())eval();
    //栈顶元素为最终答案
    cout << num.top() << endl;
    return 0;
}
```

# 队列模拟

#### easy

```c++
#include<iostream>
using namespace std;
const int N = 1e5+10;
int p[N];
int main()
{
    int head=0; //代表队伍头位置
    int pp=-1;  //队伍尾位置
    int n;
    cin >> n;
    for(int i=0;i<n;i++){
        string a;
        int x;
        cin >> a;
        if(a=="push"){
            cin >> x;
            p[++pp]=x; //插入
        }
        else if(a=="pop"){
            head++; //将头位置往后移一位达到弹出效果
        }
        else if(a=="empty"){//看尾位置比不比头位置大或等于（一个人的时候）
            if(pp>=head)cout << "NO" << endl;
            else cout << "YES" << endl;
        }
        else {
            cout << p[head] << endl;//头位置
        }
    }

    return 0;
}
```

# 单调栈

给定一个长度为 NN 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1−1。

#### 输入格式

第一行包含整数 NN，表示数列长度。

第二行包含 NN 个整数，表示整数数列。

#### 输出格式

共一行，包含 NN 个整数，其中第 ii 个数表示第 ii 个数的左边第一个比它小的数，如果不存在则输出 −1−1。

#### 数据范围

1≤N≤1051≤N≤105
1≤数列中元素≤1091≤数列中元素≤109

#### 输入样例：

```
5
3 4 2 7 5
```

#### 输出样例：

```
-1 3 -1 2 2
```

```c++
#include<iostream>
#include<stack>
using namespace std;
const int N = 1e5+10;
stack<int>p;
int a[N];

int main()
{
    int top=0;
    int n;
    cin >> n;
    for(int i=0;i<n;i++){
        int x;
        cin >> x;
        while(p.size() && p.top()>=x)p.pop();
        if(p.size())cout << p.top() << ' ';
        else cout << "-1 ";
        p.push(x);
    }

    return 0;
}
```

# 滑动窗口

给定一个大小为 n≤106n≤106 的数组。

有一个大小为 kk 的滑动窗口，它从数组的最左边移动到最右边。

你只能在窗口中看到 kk 个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 `[1 3 -1 -3 5 3 6 7]`，kk 为 33。

|      窗口位置       | 最小值 | 最大值 |
| :-----------------: | :----: | :----: |
| [1 3 -1] -3 5 3 6 7 |   -1   |   3    |
| 1 [3 -1 -3] 5 3 6 7 |   -3   |   3    |
| 1 3 [-1 -3 5] 3 6 7 |   -3   |   5    |
| 1 3 -1 [-3 5 3] 6 7 |   -3   |   5    |
| 1 3 -1 -3 [5 3 6] 7 |   3    |   6    |
| 1 3 -1 -3 5 [3 6 7] |   3    |   7    |

你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

#### 输入格式

输入包含两行。

第一行包含两个整数 nn 和 kk，分别代表数组长度和滑动窗口的长度。

第二行有 nn 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

#### 输出格式

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

#### 输入样例：

```
8 3
1 3 -1 -3 5 3 6 7
```

#### 输出样例：

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```



```c++
#include<iostream>
#include<deque>
using namespace std;
const int N = 1e6+10;

deque<int>p;
int a[N],q[N];//q记录下标

int main()
{
    int n,k;
    cin >> n >> k;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);

    for(int i=1;i<=n;i++){
        while(p.size() && p.back()>a[i])p.pop_back();//如果当前数比队列末的数小就把末位数弹出直至不小于为止（把小的数往队列前面移动）
        p.push_back(a[i]);
        if(i-k>=1 && p.front()==a[i-k])p.pop_front();//若队头是否滑出了窗口，队头出队 
        if(i>=k)cout << p.front() << ' ';
    }
    p.clear();
    cout << endl;
    for(int i=1;i<=n;i++){
        while(p.size() && p.back()<a[i])p.pop_back();
        p.push_back(a[i]);
        if(i-k>=1 && p.front()==a[i-k])p.pop_front();
        if(i>=k)cout << p.front() << ' ';
    }

    return 0;
}
```



# KMP

## 对字符串搜索的优化，当匹配字符失败时不需要回溯，跳过先前匹配成功的字符串继续线性前进，时间复杂度为O(m+n)

[【最浅显易懂的 KMP 算法讲解】https://www.bilibili.com/video/BV1AY4y157yL?vd_source=d822d177348c71c285e07dfb31013776]()

[[KMP算法中最大公共前后缀长度的理解（逐步分析）_最长公共前后缀-CSDN博客](https://blog.csdn.net/m0_74766888/article/details/133807237)]()

### NEXT数组（记录字串中的最长前缀和后缀，也就是重复的部分）

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241112203259694.png)

```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N = 1e6+10;
char s1[N],s2[N];
int s[N];
int l1,l2;

void getnext(){
    int j = 0;
    for(int i = 1; i < l2 ; i++){//i指针指向的是后缀末尾，j指针指向的是前缀末尾
        while(j > 0 && s2[i] != s2[j])j = s[j-1];//前后缀不相同，去找j前一位的最长相等前后缀
        if(s2[i] == s2[j])j++;//前后缀相同，j指针后移
        s[i] = j;
    }
}

int main()
{
    scanf("%s %s",s1,s2);
    l1 = strlen(s1);
    l2 = strlen(s2);

    getnext();
    int j = 0;
    for(int i = 0 ; i < l1 ; i++){
        while(j > 0 && s1[i] != s2[j])j = s[j-1]; //不相等回退子串指针
        if(s1[i] == s2[j])j++;
        if( j == l2 ){
            printf("%d\n",i - l2 + 2);//输出所在位置
            j = s[j - 1]; //返回上一部分相同的位置
        }
    }

    for(int i = 0 ; i < l2 ; i++)printf("%d ",s[i]);

    return 0;
}
```

# Trie字符串统计

## **Trie的概念:** 高效地存储和查找字符串集合的数据结构

![](C:\Users\30959\Pictures\159992cbf703fd7a3364d1d39a699aa7.png)

```c++
#include<iostream>
using namespace std;
const int N = 1e5+10;

int son[N][26] , cnt[N] , idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量
char s[N];
// 插入一个字符串
void insert(){
    int j = 0;
    for(int i = 0 ; s[i] ; i++){
        int k = s[i] - 'a';
        if(!son[j][k])son[j][k] = ++idx;
        j = son[j][k];
    }
    cnt[j]++;
}
// 查询字符串出现的次数
int query(){
    int j = 0;
    for(int i = 0 ; s[i] ; i++){
        int k = s[i] - 'a';
        if(!son[j][k])return 0;
        j = son[j][k];
    }
    return cnt[j];
}

int main()
{
    int n;
    cin >> n;
    while( n -- ){
        char op;
        cin >> op >> s;
        if(op == 'I')insert();
        else printf("%d\n",query());
    }

    return 0;
}
```



# 最大异或对

## 利用二叉树来优化了数字的搜搜与存储

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115161916712.png)

```c++
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
// 注意son和cnt的结点个数=所有输入的符号总数=数的数量*31
int son[31 * N][2] , idx;
int a[N];

// 将每一个整数看成一个31位的二进制数
void insert(int x){
    int j  = 0;
    for(int i = 30 ; i >= 0 ; i--){
        int &p = son[j][x >> i & 1];
        if(p == 0) p = ++idx; //如果节点不存在，下标加一创立新节点
        j = p;
    }
}

int query(int x){
    int res = 0 , p = 0;
    for(int i = 30 ; i >= 0 ; i--){
        int s = x >> i & 1;
        //如果是1则取0,如果不存在就选1
        if(son[p][!s]){
            res += 1 << i;
            p = son[p][!s];
        }
        else {
            res += 0 << i; //可省略
            p = son[p][s];
        }
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    for(int i = 0 ; i < n ; i++)cin >> a[i] , insert(a[i]);
    int res = 0;
    for(int i = 0 ; i < n ; i++)res = max(res, query(a[i]));

    cout << res;

    return 0;
}
```



# 二叉树

### 满二叉树：![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115175310664.png)

### 完全二叉树（叶子节点可以缺失，但只能是最靠右的叶子）：![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115175858338.png)

###  ![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115175600609.png)

### 错误完全二叉树：![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115175709747.png)

### 树左子节点：![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115180124172.png)

### 数右子节点：![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115180340213.png)

### 用数组存储二叉树应是完全二叉树或者满二叉树，因为（非该两种情况会有空间浪费）：

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115181036935.png)

## 关于二叉树的应用：

### 堆的实现：堆的实质就是完全二叉树

[洛谷关于堆的模板题](https://www.luogu.com.cn/problem/P3378)

```c++
#include<iostream>
using namespace std;
const int N = 1e6 + 10;
int p[N] , idx;//idx表示堆的数量
//插入一个数
void insert(int x){ 
    p[++idx] = x;
    int now = idx;
    while(now){
        int dadidx = now / 2; //找到自己的父亲节点
        if(p[dadidx] > p[now])swap(p[dadidx],p[now]); //交换
        else break;//如果不小于就则说明已满足
        now /= 2;//继续往上寻找父亲节点
    }
}
//删除最小数（树根底）
void pop(){
    swap(p[idx],p[1]);//先把根底数与堆最后的数交换，删除，再把根数交换，维护堆的规则（从小到大）
    idx--; 
    int now = 1;
    //往下寻找叶子节点
    while((now * 2) <= idx){
        int k = now * 2;
        if(p[k + 1] < p[k] && k + 1 <= idx)k++; //判断左叶子节点和右叶子节点哪个小，选择交换的叶子节点
        if(p[now] > p[k])swap(p[now],p[k]); //如果父亲节点比儿子节点大则交换
        else break; //无则说明顺序正常，结束
        now = k； //继续往下寻找叶子节点
    }
}

int main()
{
    int n;
    cin >> n;
    while(n--){
        int op;
        cin >> op;
        if(op == 1){
            int a;
            cin >> a;
            insert(a);
        }
        else if(op == 2)cout << p[1] << endl;
        else pop();
    }

    return 0;
}
```



# 合并集合

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 mm 个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

#### 输入格式

第一行输入整数 n 和 m。

接下来 mm 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。

#### 输出格式

对于每个询问指令 `Q a b`，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

1≤n,m≤1051≤n,m≤105

#### 输入样例：

```
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```

#### 输出样例：

```
Yes
No
Yes
```

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241115203033653.png)

#### 用编号划分每个数的所在集合，当改变所在集合位置时，通过把根编号赋值给被改变集合

```c++
#include<iostream>
using namespace std;
const int N = 1e5+10;
int dad[N];

int find(int x){							//查找x的根   	
    if(dad[x] != x)dad[x] = find(dad[x]);	//如果x的根不是自己，就继续递归下去找根
    return dad[x];							//找到根就返回(返回根的值)
}

int main()
{
    int n,m;
    cin >> n >> m;

    for(int i = 1 ; i <= n ; i++)dad[i] = i;

    int a,b;
    while(m -- ){
        char op;
        cin >> op >> a >> b;
        if(op == 'M') dad[find(a)] = find(b); //把b集合的根传给a，实现合并
        else {
            if(find(a) == find(b))cout << "Yes" << endl;
            else cout << "No" << endl;
        }
    }

    return 0;
}
```



```
#include<iostream>
using namespace std;
const int N = 5 * 1e3 + 10;
int a[N];

int pp(int x){
    while(a[x] != x)x = a[a[x]];//如果当前号不与之匹配，就继续搜寻该节点(a[x])的根(a[a[x]]);
    return x;//如果相等后就返回
}

int main()
{
    int n,m,p;
    cin >> n >> m >> p;
    for(int i = 1 ; i <= n ; i++)a[i] = i;

    for(int i = 0 ; i < m ; i++){
        int j,k;
        cin >> k >> j;
        a[pp(k)] = pp(j); //如果左右边是两个独立的数（j,k），就找到左边树的根，和右边树的根，把右边数的根值赋值给左边的树根，实现把左树接在右树下，成为其一个子节点
    }

    while(p--){
        int j,k;
        cin >> j >> k;
        if(pp(j) == pp(k))cout << "Yes" << endl;
        else cout << "No" << endl;
    }

    return 0;
}
```

# 连通块中点的数量

给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。

现在要进行 m 个操作，操作共有三种：

1. `C a b`，在点 a 和点 b 之间连一条边，aa 和 bb 可能相等；
2. `Q1 a b`，询问点 a 和点 b 是否在同一个连通块中，aa 和 bb 可能相等；
3. `Q2 a`，询问点 a 所在连通块中点的数量；

#### 输入格式

第一行输入整数 n 和 m。

接下来 mm 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。

#### 输出格式

对于每个询问指令 `Q1 a b`，如果 aa 和 bb 在同一个连通块中，则输出 `Yes`，否则输出 `No`。

对于每个询问指令 `Q2 a`，输出一个整数表示点 aa 所在连通块中点的数量

每个结果占一行。

#### 数据范围

1≤n,m≤1051≤n,m≤105

#### 输入样例：

```
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
```

#### 输出样例：

```
Yes
2
3
```

#### 比合并集合多了个要素，树的元素数量num

```c++
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int num[N];

int find(int x){
    if(a[x] != x)a[x] = find(a[x]);
    return a[x];
}

int main()
{
    int n,m;
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i++)a[i] = i , num[i] = 1;

    while( m -- ){
        char op[3];
        cin >> op;
        int k1,k2;
        if(op[0] == 'C'){
            cin >> k1 >> k2;
            if(find(k1) == find(k2))continue;
            num[find(k2)] += num[find(k1)]; //应该在根节点改变之前加上树的元素数量，如果在改变后加上，则可能不是，原先要加上的根节点的数量
            a[find(k1)] = find(k2);

        }
        else if(op[1] == '1'){
            cin >> k1 >> k2;
            if(find(k1) == find(k2))cout << "Yes" << endl;
            else cout << "No" << endl;
        }
        else {
            cin >> k1;
            cout << num[find(k1)] << endl;
        }
    }

    return 0;
}
```

# 食物链(带权并查集)

动物王国中有三类动物 A,B,CA,B,C，这三类动物的食物链构成了有趣的环形。

A 吃 B，B 吃 C，C 吃 A。

现有 NN 个动物，以 1∼N1∼N 编号。

每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 NN 个动物所构成的食物链关系进行描述：

第一种说法是 `1 X Y`，表示 X 和 Y 是同类。

第二种说法是 `2 X Y`，表示 X 吃 Y。

此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

1. 当前的话与前面的某些真的话冲突，就是假话；
2. 当前的话中 X 或 Y 比 N 大，就是假话；
3. 当前的话表示 X 吃 X，就是假话。

你的任务是根据给定的 N 和 K 句话，输出假话的总数。

#### 输入格式

第一行是两个整数 N 和 K，以一个空格分隔。

以下 KK 行每行是三个正整数 D，X，YD，X，Y，两数之间用一个空格隔开，其中 D 表示说法的种类。

若 D=1，则表示 X 和 Y 是同类。

若 D=2，则表示 X 吃 Y。

#### 输出格式

只有一个整数，表示假话的数目。

#### 数据范围

1≤N≤500001≤N≤50000,
0≤K≤1000000≤K≤100000

#### 输入样例：

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
```

#### 输出样例：

```
3
```

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241118192629126.png)

## 距离就是代数（第几个节点），根据代数模3，看余数为多少来判断其是哪一类

## 距离的计算：假设一个点X（编号与对应数组不相等），计算到p[x]的距离，在向下查找时p[x]会更新为根节点(所以要设个temp来临时存储更新后的值，在计算完距离后在让p[x] = temp)，距离就变成了x到p[x]的距离再加上p[x]到根节点的距离，d[x] = d[x] + d[p[x]] >>----->> d[x] +=d[p[x]]

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241118193441845.png)

```c++
#include<iostream>
using namespace std;
const int T = 50010;
int N,K;
int son[T],dis[T];

int find(int x){
    if(son[x] != x){
        int temp = find(son[x]);
        dis[x] += dis[son[x]];
        son[x] = temp;
    }
    return son[x];
}

int main()
{
    cin >> N >> K;
    int wro = 0;
    for(int i = 1 ; i <= N ; i++)son[i] = i;

    while(K--){
        int t,x,y;
        cin >> t >> x >> y;
        if(x > N || y > N) wro ++ ;
        else {
            int son_x = find(x) , son_y = find(y); //找出x,y的根节点
            if(t == 1){
                if(son_x == son_y && (dis[x] - dis[y]) % 3 != 0) wro ++ ; //在同一个集合里（一个树里），但是到根节点端的距离%3不相等，说明不是同类，说假话
                //如果不在一个树里，要先接在一起
                else if(son_x != son_y){
                      son[son_x] = son_y; //把x接在y上
                      dis[son_x] = dis[y] - dis[x];
                }
            }
            else {
                if(son_x == son_y && (dis[x] - dis[y] - 1) % 3) wro ++;
                else if(son_x != son_y){
                    son[son_x] = son_y;
                    dis[son_x] = dis[y] + 1 -dis[x];
                }
            }
        }
    }

    cout << wro;

    return 0;
}
```

# 模拟堆

维护一个集合，初始时集合为空，支持如下几种操作：

1. `I x`，插入一个数 xx；
2. `PM`，输出当前集合中的最小值；
3. `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4. `D k`，删除第 kk 个插入的数；
5. `C k x`，修改第 kk 个插入的数，将其变为 xx；

现在要进行 NN 次操作，对于所有第 22 个操作，输出当前集合的最小值。

#### 输入格式

第一行包含整数 NN。

接下来 NN 行，每行包含一个操作指令，操作指令为 `I x`，`PM`，`DM`，`D k` 或 `C k x` 中的一种。

#### 输出格式

对于每个输出指令 `PM`，输出一个结果，表示当前集合中的最小值。

每个结果占一行。

#### 数据范围

1≤N≤1051≤N≤105
−109≤x≤109−109≤x≤109
数据保证合法。

#### 输入样例：

```
8
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
```

#### 输出样例：

```
-10
6
```

```c++
#include<iostream>
using namespace std;
const int N = 1e6 + 10;

int heap[N] , heap_p[N], p_heap[N] , idx;

void heap_swap(int a,int b){
    swap(p_heap[heap_p[a]],p_heap[heap_p[b]]);
    swap(heap_p[a],heap_p[b]);
    swap(heap[a],heap[b]);
}

void up(int x){
    int k = x / 2;
    while(k && heap[x] && heap[k] > heap[x]){
        heap_swap(k,x);
        x /= 2;
    }
}
void down(int x){
    int k = 2 * x;
    if(k <= idx && heap[k + 1] < heap[k]) k ++ ;
    if(heap[x] > heap[k]){
        heap_swap(k,x);
        down(k);
    }
}

int main()
{
    int n , p = 0;
    cin >> n;

    while( n -- ){
        string op;
        int x;
        cin >> op;
        if(op == "I"){
            cin >> x;
            heap[ ++ idx ] = x;
            p_heap[ ++ p ] = idx;
            heap_p[idx] = p;
            up(idx); //在最底部插入,往上扫描维护堆(up)
        }
        else if(op == "PM")cout << heap[1] << endl;
        else if(op == "DM"){
            heap_swap(1,idx);
            idx -- ;
            down(1);//删除第一个数后,原先在底部的数在第一个位置,从上往下扫描(down)
        }
        else if(op == "D"){
            cin >> x;
            x = p_heap[x];
            heap_swap(x,idx);
            idx -- ;
            up(x);
            down(x);
        }
        else {
            int k;
            cin >> k >> x;
            k = p_heap[k];
            heap[k] = x;
            up(k);
            down(k);
        }
    }

    return 0;
}
```

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241119165118938.png)

![image-20241119165209569](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241119165209569.png)

# 对顶堆（大根堆 && 小根堆）

#### 小根堆就是从小到大排，最小的值做根底

#### 大根堆就是从大到小排，最大的值做根底

![image-20241202104844026](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241202104844026.png)



### 上为小根堆，下为大根堆（因为大根堆为降序，小根堆为升序，只要保证，小根堆的根底比大根堆的根底大，就可以使得，小根堆里的元素 都大于 大根堆



### 所以可以发现，整个对顶堆内部的元素是从上往下逐层递减



# 黑匣子（利用对顶堆）

## 题目描述

Black Box 是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量 i*i*。最开始的时候 Black Box 是空的．而 i=0*i*=0。这个 Black Box 要处理一串命令。

命令只有两种：

- `ADD(x)`：把 x*x* 元素放进 Black Box;
- `GET`：i*i* 加 11，然后输出 Black Box 中第 i*i* 小的数。

记住：第 i*i* 小的数，就是 Black Box 里的数的按从小到大的顺序排序后的第 i*i* 个元素。

我们来演示一下一个有11个命令的命令串。（如下表所示）

| 序号 | 操作         | i*i* | 数据库             | 输出 |
| :--: | :----------- | :--: | ------------------ | :--: |
|  1   | `ADD(3)`     |  0   | 3                  |  /   |
|  2   | `GET`        |  1   | 3                  |  3   |
|  3   | `ADD(1)`     |  1   | 1,3                |  /   |
|  4   | `GET`        |  2   | 1,3                |  3   |
|  5   | `ADD(-4)`    |  2   | −4,1,3             |  /   |
|  6   | `ADD(2)`     |  2   | −4,1,2,3           |  /   |
|  7   | `ADD(8)`     |  2   | −4,1,2,3,8         |  /   |
|  8   | `ADD(-1000)` |  2   | −1000,−4,1,2,3,8   |  /   |
|  9   | `GET`        |  3   | −1000,−4,1,2,3,8   |  1   |
|  10  | `GET`        |  4   | −1000,−4,1,2,3,8   |  2   |
|  11  | `ADD(2)`     |  4   | −1000,−4,1,2,2,3,8 |  /   |

现在要求找出对于给定的命令串的最好的处理方法。`ADD` 命令共有 m*m* 个，`GET` 命令共有 n*n* 个。现在用两个整数数组来表示命令串：

1. a1,a2,⋯ ,am*a*1,*a*2,⋯,*a**m*：一串将要被放进 Black Box 的元素。例如上面的例子中 a=[3,1,−4,2,8,−1000,2]*a*=[3,1,−4,2,8,−1000,2]。
2. u1,u2,⋯ ,un*u*1,*u*2,⋯,*u**n*：表示第 ui*u**i* 个元素被放进了 Black Box 里后就出现一个 `GET` 命令。例如上面的例子中 u=[1,2,6,6]*u*=[1,2,6,6] 。输入数据不用判错。

## 输入格式

第一行两个整数 m*m* 和 n*n*，表示元素的个数和 `GET` 命令的个数。

第二行共 m*m* 个整数，从左至右第 i*i* 个整数为 ai*a**i*，用空格隔开。

第三行共 n*n* 个整数，从左至右第 i*i* 个整数为 ui*u**i*，用空格隔开。

## 输出格式

输出 Black Box 根据命令串所得出的输出串，一个数字一行。

## 输入输出样例

**输入 #1**复制

```
7 4
3 1 -4 2 8 -1000 2
1 2 6 6
```

**输出 #1**复制

```
3
3
1
2
```

## 说明/提示

#### 数据规模与约定

- 对于 30%30% 的数据，1≤n,m≤1041≤*n*,*m*≤104。
- 对于 50%50% 的数据，1≤n,m≤1051≤*n*,*m*≤105。
- 对于 100%100% 的数据，1≤n,m≤2×105,∣ai∣≤2×1091≤*n*,*m*≤2×105,∣*a**i*∣≤2×109，保证 u*u* 序列单调不降。

### 如果正常模拟堆，时间复杂度大概是O(n²) ，n = 2 * 1e5



```c++
#include<iostream>
#include<queue>
using namespace std;
const int N = 2 * 1e5 + 10;

priority_queue<int,vector<int>,greater<int>>s;
priority_queue<int,vector<int>,less<int>>b;

int a[N] , u[N];

int main()
{
    int m , n;
    cin >> m >> n;

    for(int i = 1 ; i <= m ; i ++ )cin >> a[i];
    for(int i = 1 ; i <= n ; i ++ )cin >> u[i];

    int j = 0;

    for(int i = 1 ; i <= n ; i ++ ){
		//插入元素到小根堆里 , 当 元素个数 和 指令要求数 相同时跳出循环
        while(j < u[i]){
            //先插入大根堆再插入小根堆
            b.push(a[ ++ j]);
            s.push(b.top());
            b.pop();
        }
        //大根堆b里保证有i - 1个数 ， 小根堆根底就是第i小的数
        cout << s.top() << endl;
        //输出后将小根堆根底的数插入大根堆，使得大根堆里的元素个数到i（相当于（i-1）+ 1）， 下一次就是输出的就是第 （i + 1） 个小的数；
        b.push(s.top());
        s.pop();
    }

    return 0;
}
```



# 哈希表

## 模拟散列表

维护一个集合，支持如下几种操作：

1. `I x`，插入一个整数 xx；
2. `Q x`，询问整数 xx 是否在集合中出现过；

现在要进行 NN 次操作，对于每个询问操作输出对应的结果。

#### 输入格式

第一行包含整数 NN，表示操作数量。

接下来 NN 行，每行包含一个操作指令，操作指令为 `I x`，`Q x` 中的一种。

#### 输出格式

对于每个询问指令 `Q x`，输出一个询问结果，如果 xx 在集合中出现过，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

1≤N≤1051≤N≤105
−109≤x≤109−109≤x≤109

#### 输入样例：

```
5
I 1
I 2
I 3
Q 2
Q 5
```

#### 输出样例：

```
Yes
No
```



## 拉链寻址法(数组+单链表)

### 通过将一个树mod（%）去数组上限下标，再将其存入数组当中，如果有存在相同的数组时，通过开辟一个链表来连接

![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241119175145692.png)

```c++
#include<iostream>
#include <cstring>
using namespace std;
const int N = 1e5 + 10;
int h[N] , val[N] , ne[N] , idx;

void insert(int x){
    int k = (x % N + N) % N; //应对x如果是个负数的情况
    val[idx] = x; //存储值进链表
    ne[idx] = h[k]; //存储指针
    h[k] = idx++;
}

bool find(int x){
    int k = (x % N + N) % N;
    for(int i = h[x] ; i != -1 ; i = ne[i]){
        if(val[i] == x)return true;
    }
    return false;
}

int main()
{
    int n;
    cin >> n;

    memset(h,-1,sizeof  h);

    while(n -- ){
        char op;
        int x;
        cin >> op >> x;
        if(op == 'I')insert(x);
        else {
            if(find(x))cout << "Yes" << endl;
            else cout << "No" << endl;
        }

    }

    return 0;
}
```

## 字符串哈希

给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2l1,r1,l2,r2，请你判断 [l1,r1][l1,r1] 和 [l2,r2][l2,r2] 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

#### 输入格式

第一行包含整数 n 和 m，表示字符串长度和询问次数。

第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。

接下来 mm 行，每行包含四个整数 l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。

注意，字符串的位置从 11 开始编号。

#### 输出格式

对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

1≤n,m≤1051≤n,m≤105

#### 输入样例：

```
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
```

#### 输出样例：

```
Yes
No
Yes
```

![image-20241119202330889](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241119202330889.png)



![](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241119202203492.png)

```c++
#include<iostream>
using namespace std;
typedef unsigned long long ull;
const int  N = 1e5 + 10 , P = 131;
char b[N];
//把字符串看成P进制的数
ull h[N] , p[N]; //h数组用来存储字符串的哈希值，p用来记录位数

ull get(int l,int r){
    return h[r] - h[l - 1] * p[r - l + 1];//举个例子123456和1234，如果要算出56，要先把1234处理与123456同位，变成123400，再算123456-123400=56
}

int main()
{
    int n,q;
    p[0] = 1;
    cin >> n >> q;
    scanf("%s",b + 1);

    for(int i = 1 ; i <= n ; i ++ ){
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + b[i];
    }

    while(q -- ){
        int l1,l2,r1,r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if(get(l1,r1) == get(l2,r2))cout << "Yes" << endl;
        else cout << "No" << endl;
    }

    return 0;
}
```

# DFS（深度优先搜索）

## 全排列

给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

#### 输入格式

共一行，包含一个整数 n。

#### 输出格式

按字典序输出所有排列方案，每个方案占一行。

#### 数据范围

1≤n≤7 1≤n≤7

#### 输入样例：

```
3
```

#### 输出样例：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

```c++
#include<iostream>
using namespace std;

int a[10] , n;
bool yn[10];//记录数字是否被使用过

void dfs(int x){
    //当所有数字都被标记过一次后输出
    if(x > n){
        for(int i = 1 ; i <= n ; i ++ )cout << a[i] << ' ';
        cout << endl;
    }
    for(int i = 1 ; i <= n ; i ++ ){ //每次从1开始查找
        //未被使用
        if(yn[i] == 0) {
            a[x] = i;
            yn[i] = 1;
            dfs(x + 1);//递归至下一层
            yn[i] = 0;//递归返回后解除对数的标记,继续往下查找下一个数
        }
    }
}

int main()
{
    cin >> n;

    dfs(1);

    return 0;
}
```

## n-皇后问题

n−n−皇后问题是指将 nn 个皇后放在 n×nn×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

![1_597ec77c49-8-queens.png](https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png)

现在给定整数 nn，请你输出所有的满足条件的棋子摆法。

#### 输入格式

共一行，包含整数 nn。

#### 输出格式

每个解决方案占 nn 行，每行输出一个长度为 nn 的字符串，用来表示完整的棋盘状态。

其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

**注意：行末不能有多余空格。**

输出方案的顺序任意，只要不重复且没有遗漏即可。

#### 数据范围

1≤n≤91≤n≤9

#### 输入样例：

```
4
```

#### 输出样例：

```
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
```



```c++
#include<iostream>
using namespace std;

int n;
char que[12][12];
bool dg[20] , udg[20] , l[12]; //记录，对角线，反对角线，是否有棋子的数组（有2n - 1）条，以及n列

void dfs(int x){
    if(x > n) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                cout << que[i][j];
            }
            cout << endl;
        }
        cout << endl;
    }
    for(int i = 1 ; i <= n ; i ++ ){
        if(!dg[x + i] && !udg[n - x + i] && !l[i]){
            que[x][i] = 'Q';
            l[i] = dg[x + i] = udg[n - x + i] = true;
            dfs(x + 1); //当前行存放棋子后直接跳到下一行放棋子
            l[i] = dg[x + i] = udg[n - x + i] = false;//递归回来后收回当前位置的棋子，往下继续寻找能存放的位置
            que[x][i] = '.';
        }
    }

}

int main()
{
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )for(int j = 1 ; j <= n ; j ++ )que[i][j] = '.';
    dfs(1);

    return 0;
}
```



# BFS(宽度优先搜索)

## 走迷宫

给定一个 n×mn×m 的二维整数数组，用来表示一个迷宫，数组中只包含 00 或 11，其中 00 表示可以走的路，11 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1)(1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m)(n,m) 处，至少需要移动多少次。

数据保证 (1,1)(1,1) 处和 (n,m)(n,m) 处的数字为 00，且一定至少存在一条通路。

#### 输入格式

第一行包含两个整数 nn 和 mm。

接下来 nn 行，每行包含 mm 个整数（00 或 11），表示完整的二维数组迷宫。

#### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

#### 数据范围

1≤n,m≤1001≤n,m≤100

#### 输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
8
```



```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
typedef pair<int,int> pp;
const int N = 110;

int mp[N][N]; //存储地图
int d[N][N];  //存储每个点离起点的距离（按照一个方式走）
pp q[N * N];  //创建一个队列，当每次走到一个新的点时，存放这个点上下左右相邻的点
int n,m;

int bfs(){
    //队头,队尾
    int hh = 1 , tt =1;
    q[1] = {1,1};//第一个点
    memset(d , -1 , sizeof d);
    d[1][1] = 0;
    //分别对应，向下(-1,0),向右(0,1),向上(1,0),向左(0,-1)
    int dx[4] = {-1 , 0 , 1 , 0} , dy[4] = {0 , 1 , 0 , -1};
    //头在左，尾在右  //每次都会对进入队列的点计算 ， 直到走到终点
    while (hh <= tt){
        auto t = q[hh ++ ];
        //往上下左右方向分别试探查看
        for(int i = 0 ; i < 4 ; i ++ ){
            int x = t.first + dx[i];
            int y = t.second + dy[i];
            //检查该点，有没有被走过，有无障碍，有无越界
            if(x >= 1 && x <= n && y >= 1 && y <= m && mp[x][y] == 0 && d[x][y] == -1){
                //如果符合条件，到该点的距离为上一个点的距离再加1
                d[x][y] = d[t.first][t.second] + 1;
                //把该点加入队尾
                q[ ++ tt ] = {x,y};
            }
        }
    }
    return d[n][m]; //返回终点值
}

int main()
{
    cin >> n >> m;

    for(int i = 1 ; i <= n ; i ++ ){
        for(int j = 1 ; j <= m ; j ++ ){
            cin >> mp[i][j];
        }
    }

    cout << bfs();

    return 0;
}
```



## 八数码

在一个 3×33×3 的网格中，1∼81∼8 这 88 个数字和一个 `x` 恰好不重不漏地分布在这 3×33×3 的网格中。

例如：

```
1 2 3
x 4 6
7 5 8
```

在游戏过程中，可以把 `x` 与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

```
1 2 3
4 5 6
7 8 x
```

例如，示例中图形就可以通过让 `x` 先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

```
1 2 3   1 2 3   1 2 3   1 2 3
x 4 6   4 x 6   4 5 6   4 5 6
7 5 8   7 5 8   7 x 8   7 8 x
```

现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

#### 输入格式

输入占一行，将 3×33×3 的初始网格描绘出来。

例如，如果初始网格如下所示：

```
1 2 3 
x 4 6 
7 5 8 
```

则输入为：`1 2 3 x 4 6 7 5 8`

#### 输出格式

输出占一行，包含一个整数，表示最少交换次数。

如果不存在解决方案，则输出 −1−1。

#### 输入样例：

```
2 3 4 1 5 x 7 6 8
```

#### 输出样例

```
19
```



```c++
#include<iostream>
#include<algorithm>
#include<queue>
#include<unordered_map>
using namespace std;

int bfs(string p){
    string stand = "12345678x";

    //队列用来存储往四个方向交换后的字符
    queue<string>q;
    //记录每次得到的字符所用的交换次数(打比方说从123x46578交换到1234x6578用了一次)
    unordered_map<string,int> dig;

    //把初始字符推入队列
    q.push(p);
    //默认状态的移动次数为0
    dig[p] = 0;

    //上下左右
    int dx[4] = {-1,1,0,0} , dy[4] = {0,0,-1,1};

    while(q.size()){
        //每次拿出队头元素计算
        auto t = q.front();
        //弹出队头
        q.pop();

        //次数为移动至当前状态所用次数
        int dis = dig[t];

        //如果已经达到当前预期效果直接返回值(最早返回的使用次数最早)
        if(t == stand) return dis;

        //找出一维状态下x的坐标
        int pos = t.find('x');
        //转化为二维
        int x = pos / 3 , y = pos % 3;

        //四个方向查找
        for(int i = 0 ; i < 4 ; i ++ ){
            //移动后的坐标
            int x1 = x + dx[i] , y1 = y + dy[i];
            //如果新坐标不越界
            if(x1 >= 0 && x1 < 3 && y1 >= 0 && y1 < 3){
                //先交换
                swap(t[pos],t[x1 * 3 + y1]);
                //查看是否之前有出现过一样的状态,无则记录到达当前状态,所用的移动次数
                if(dig.count(t) == 0){
                    //先前的次数 + 1
                    dig[t] = dis + 1;
                    //将当前状态加入队列
                    q.push(t);
                }
                //恢复原来状态
                swap(t[pos],t[x1 * 3 + y1]);
            }
        }
    }
    //如果所有方向不断试探后无结果
    return -1;
}

int main()
{
    string p;
    for(int i = 0 ; i < 9 ; i ++ ){
        char op;
        cin >> op;
        p += op;
    }

    cout << bfs(p);

    return 0;
}
```



# 树与图的深度优先遍历

## 浅谈邻接链表

![image-20241124125500766](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241124125500766.png)

```c++
#include<cstring>
#include<iostream>
using namespace std;
const int N = 1e5 + 10 , M = 2 * N;
//idx表示所用点数个数,val和next_p数组各自在物理空间上是相连的，但在使用时，只会拿出其中一个点使用，在逻辑上是相连的
int head[N] , val[M] , next_p[M] , idx;

//数组链表强在于不需要像malloc那样一个一个创建,事先创建好,虽然数组在物理空间上是相连的,但用操作在逻辑上将不同位置的数组链接起来,所以在数组物理空间上相连的意义可以不用管
//每个数组部分都作为独立的部分
void add(int a,int b){
    //先把该点的值和指针确定好 , 再让头指针指向点
    //先确定值,再让当前点的指针指向下一个点 for example:(如果是末尾的前一个点，那他就会指向-1)
    val[idx] = b , next_p[idx] = head[a] , head[a] = idx ++ ;
}

void pp(int a){
    //遍历
    for(int i = head[a] ; i != -1 ; i = next_p[i]){
        //操作内容//
    }

}

int main()
{
    //初始化所有头指针为-1
    memset(head , -1 , sizeof head);

    int n;
    cin >> n;
    int a,b;
    for(int i = 0 ; i < n ; i ++ ){
        cin >> a >> b;
        //无向边,搭建两点互通的边
        add(a,b) , add(b,a);
    }

    return 0;
}
```

### 接下来看题

给定一颗树，树中包含 n 个结点（编号 1∼n1∼n）和 n−1 条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

#### 输入格式

第一行包含整数 nn，表示树的结点数。

接下来 n−1n−1 行，每行包含两个整数 aa 和 bb，表示点 aa 和点 bb 之间存在一条边。

#### 输出格式

输出一个整数 mm，表示将重心删除后，剩余各个连通块中点数的最大值。

#### 数据范围

1≤n≤105

#### 输入样例

```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

#### 输出样例：

```
4
```



```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
//数据范围是10的5次方    //以有向图的格式存储无向图，所以每个节点至多对应2n-2条边
const int N = 1e5 + 10 , M = 2 * N;

int n,m;
int h[N];//邻接表存储树，有n个节点，所以需要n个队列头节点
int e[M];//存储元素(内容)
int ne[M];//存储列表的next值
int idx;//单链表指针
bool tree[N];//记录节点是否被访问过，访问过则标记为true

int ans = N;//表示重心的所有的子树中，最大的子树的结点数目

//a所对应的单链表中插入b  a作为根
void add(int a,int b){
    e[idx] = b , ne[idx] = h[a] , h[a] = idx ++ ;
}

//返回以u为根的子树中节点的个数，包括u节点
int dfs(int x){
    tree[x] = true;

    int sum = 1;//存储 以u为根的树 的节点数, 包括u，如图中的4号节点
    int res = 0;//存储 删掉某个节点之后，最大的连通子图节点数

    //访问u的每个子节点
    for(int i = h[x] ; i != -1 ; i = ne[i] ){
        int j = e[i];
        //因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过
        if(!tree[j]){
            int s = dfs(j);// u节点的单棵子树节点数 如图中的size值
            res = max(res,s);// 记录最大联通子图的
            sum += s;//以j为根的树 的节点数节点数
        }
    }

    res = max(res,n - sum);// 选择u节点为重心，最大的 连通子图节点数

    ans = min(res,ans);//遍历过的假设重心中，最小的最大联通子图的 节点数

    return sum;
}

int main()
{
    cin >> n;
    memset(h , -1 , sizeof h);//初始化h数组 -1表示尾节点
    int a,b;
    for(int i = 0 ; i < n - 1 ; i ++ ){
        cin >> a >> b;
        add(a,b) , add(b,a);
    }

    dfs(1);//无向图

    cout << ans;

    return 0;
}
```



# 图中点的层次

给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 11，点的编号为 1∼n1∼n。

请你求出 11 号点到 nn 号点的最短距离，如果从 11 号点无法走到 nn 号点，输出 −1−1。

#### 输入格式

第一行包含两个整数 nn 和 mm。

接下来 mm 行，每行包含两个整数 aa 和 bb，表示存在一条从 aa 走到 bb 的长度为 11 的边。

#### 输出格式

输出一个整数，表示 11 号点到 nn 号点的最短距离。

#### 数据范围

1≤n,m≤1051≤n,m≤105

#### 输入样例：

```
4 5
1 2
2 3
3 4
1 3
1 4
```

#### 输出样例：

```
1
```



```c++
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N = 1e5 + 10 , M = 2 * N;

int n , m;

int h[N] , dis[M] , val[M] , nex[M] , idx;

queue<int>q;

void add(int a,int b){
    val[idx] = b , nex[idx] = h[a] , h[a] = idx ++ ;
}

int bfs(){
    q.push(1);
    int t= q.front();

    while(q.size()) {
        t= q.front();
        if(t == n)return dis[t];
        q.pop();
        for (int i = h[t]; i != -1; i = nex[i]) {
            if (dis[val[i]] == 0) {
                dis[val[i]] = dis[t] + 1;
                q.push(val[i]);
            }
        }
    }

    return -1;
}

int main()
{
    memset(h , -1 , sizeof h);
    cin >> n >> m;
    int a,b;
    for(int i = 0 ; i < m ; i ++ ){
        cin >> a >> b;
        add(a,b);
    }

    cout << bfs();

    return 0;
}
```



# 有向图的拓扑排序(Topsort)

给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1−1。

若一个由图中所有点构成的序列 AA 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 mm 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。

#### 输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 −1。

#### 数据范围

1≤n,m≤105

#### 输入样例：

```
3 3
1 2
2 3
1 3
```

#### 输出样例：

```
1 2 3
```



```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N = 1e5 + 10 , M = 2 * N;

int n,m;
int h[N] , val[M] , ne[M] , idx;
int d[N] , q[N]; //d数组表示入度 ， q数组做检查存放对列

void add(int a,int b){
    val[idx] = b , ne[idx] = h[a] , h[a] = idx ++ ;
}

bool topsort(){
    int hh = 0 , tt = 0;
    for(int i = 1 ; i <= n ; i ++ )if(!d[i])q[tt ++ ] = i; //检查所有点，入度为0就放入队列

    while(hh <= tt){
        int t = q[hh ++ ];
        //删除该点，与之相连的点入读都减一
        for(int i = h[t] ; i != -1 ; i = ne[i] ){
            int j = val[i]; //查询与点t相连
            d[j] -- ;
            if(!d[j]) q[tt ++ ] = j;//如果入度已为0，继续推入队列
        }
    }
    if(tt == n)return true;

    return false;
}

int main()
{
    memset(h,-1,sizeof h);
    cin >> n >> m;
    int a,b;
    for(int i = 0 ; i < m ; i ++ ){
        cin >> a >> b;
        add(a,b);
        d[b] ++ ;
    }

    if(topsort()){
        for(int i = 0 ; i < n ; i ++ ){
            printf("%d ",q[i]);
        }
        puts("");
    }
    else puts("-1");

    return 0;
}
```



# Dijkstra求最短路 I

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

#### 数据范围

1≤n≤500,
1≤m≤105,
图中涉及边长均不超过10000。

#### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

#### 输出样例：

```
3
```

[动画讲解（不同代码）](【最短路径 迪杰斯特拉 dijkstra算法 数据结构与算法】https://www.bilibili.com/video/BV1QESyYGE55?vd_source=d822d177348c71c285e07dfb31013776)

```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N = 510;

int n , m;
int mp[N][N];
int dist[N];
bool rd[N];

int dj(){
    dist[1] = 0;

    for(int i = 0 ; i < n - 1 ; i ++ ){//起点开始计数所以为n-1
        int t = -1;

        for(int j = 1 ; j <= n ; j ++ ){
            if(!rd[j] && (t == -1 || dist[t] > dist[j]))t = j;
        }

        for(int j = 1 ; j <= n ; j ++ ){
            dist[j] = min(dist[j],dist[t] + mp[t][j]);
        }

        rd[t] = true;
    }

    if(dist[n] == 0x3f3f3f3f)return -1;

    return dist[n];
}

int main()
{
    scanf("%d %d",&n,&m);

    memset(mp,0x3f,sizeof mp);
    memset(dist,0x3f,sizeof dist);

    while( m -- ){
        int a,b,c;
        scanf("%d %d %d",&a,&b,&c);

        mp[a][b] = min(mp[a][b],c);
    }

    printf("%d",dj());

    return 0;
}
```



# Dijkstra求最短路 II

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

#### 数据范围

1≤n,m≤1.5×105,
图中涉及边长均不小于 00，且不超过 10000。
数据保证：如果最短路存在，则最短路的长度不超过 109。

#### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

#### 输出样例：

```
3
```



```c++
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
typedef pair<int,int>pp;
const int N = 1e6 + 10;

int n , m;
int h[N] , w[N] , val[N] , ne[N] , idx;
int dist[N];
int p[N];

void add(int a,int b,int c){
    val[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;
}

int dijkstra(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;
    priority_queue<pp,vector<pp>,greater<pp>>heap;
    heap.push({0,1}); // 第一个为从起点到该点的距离 , 第二个为点
    //因为为优先队列
    //每次插入数据,总是第一个数最小的排在前,即heap.first
    while(heap.size()){

        auto t = heap.top();
        heap.pop();

        int ver = t.second , distance = t.first;

        if(p[ver])continue;
        p[ver] = true;

        for(int i = h[ver] ; i != -1 ; i = ne[i]){
            int j = val[i];
            //当存在从起始点到j点更短的路径就进行更新
            //为什么说他一定是最优距离呢？
            //假设有其他点到ver的距离+其到原点的距离小于现有的距离，那么他一定会优先考虑，也就不会有该操作
            //如果发现,新的路径到一个点的距离小于先前保存的距离,更新
            if(dist[j] > dist[ver] + w[i]){
                dist[j] = dist[ver] + w[i];
                //如果距离比先前的小,插入该点
                heap.push({dist[j],j});
            }
        }
    }

    if(dist[n] == 0x3f3f3f3f)return -1;

    return dist[n];
}

int main()
{
    scanf("%d %d",&n,&m);

    memset(h,-1,sizeof h);

    while(m -- ){
        int a,b,c;
        scanf("%d %d %d",&a,&b,&c);
        add(a,b,c);
    }

    printf("%d\n",dijkstra());

    return 0;
}
```



# Bellman-ford算法(有点像Dijkstra,但不是)

## 有边数限制的最短路

给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出从 11 号点到 nn 号点的最多经过 kk 条边的最短距离，如果无法从 11 号点走到 nn 号点，输出 `impossible`。

注意：图中可能 **存在负权回路** 。

#### 输入格式

第一行包含三个整数 n,m,kn,m,k。

接下来 mm 行，每行包含三个整数 x,y,zx,y,z，表示存在一条从点 xx 到点 yy 的有向边，边长为 zz。

点的编号为 1∼n1∼n。

#### 输出格式

输出一个整数，表示从 11 号点到 nn 号点的最多经过 kk 条边的最短距离。

如果不存在满足条件的路径，则输出 `impossible`。

#### 数据范围

1≤n,k≤5001≤n,k≤500,
1≤m≤100001≤m≤10000,
1≤x,y≤n1≤x,y≤n，
任意边长的绝对值不超过 1000010000。

#### 输入样例：

```
3 3 1
1 2 1
2 3 1
1 3 3
```

#### 输出样例：

```
3
```



![511a071829d8a1b2f72ac8003424d3c1](D:\QQ文件\Tencent Files\3029281534\nt_qq\nt_data\Pic\2024-12\Ori\511a071829d8a1b2f72ac8003424d3c1.jpg)



```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
typedef pair<int,int>pp;
const int N = 1e5 + 10;

//Bellman-ford与Dijkstra的区别,前者只需要算边即可计算距离,而后者是从最小点开始一个一个点搜寻,所以记录前者数据用结构体即可,不需要邻接链表
struct bag{
    int start;
    int end;
    int l;
}bag[N];
int n , m , k;
int dist[N] , before[N];

int find_road(){
    memset(dist,0x3f,sizeof dist);

    dist[1] = 0;
	//走K遍
    for(int i = 1 ; i <= k ; i ++ ){
        //before数组拷贝上次走过一次后,最新的dist数组
        memcpy(before,dist,sizeof dist);
        //把所有边走一边(但实质上遍历完一次只会更新因为一开始所有dist的值都为正无穷大就只有原点可以更新,满足dist[2] > dist[1]+c,当下次为(2 --> 3)时,即dist[3] = min(dist[3],dist[2] + c) , 但问题在于此时dist[2],dist[3]都为正无穷大,所以更新完还是等于无穷大)
        for(int j = 1 ; j <= m ; j ++ ){
            int a = bag[j].start , b = bag[j].end , c = bag[j].l;
            dist[b] = min(dist[b],before[a] + c);
        }
    }

    if(dist[n] > 0x3f3f3f3f / 2)return -1;
    return dist[n];
}

int main()
{
    cin >> n >> m >> k;

    for(int i = 1 ; i <= m ; i ++ ){
        cin >> bag[i].start >> bag[i].end >> bag[i].l;
    }

    int res = find_road();

    if(res == -1 && dist[n] != -1)cout << "impossible";
    else cout << res;

    return 0;
}
```



![image-20241209203731630](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241209203731630.png)



# Spfa(对Bellman-ford的优化)

## spfa求最短路 

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 `impossible`。

数据保证不存在负权回路。

#### 输入格式

第一行包含整数 n 和 m。

接下来 mm 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 `impossible`。

#### 数据范围

1≤n,m≤105,
图中涉及边长绝对值均不超过 10000。

#### 输入样例：

```
3 3
1 2 5
2 3 -3
1 3 4
```

#### 输出样例：

```
2
```



```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N = 1e5 + 10;

int n,m;
int h[N] , ne[N] , val[N] , w[N] , idx;
int dist[N];
bool str[N];

void add(int a,int b, int c){
    val[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;
}

void spfa(){
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;

    queue<int>q;
    q.push(1);
    str[1] = true;

    while(q.size()){
        int t = q.front();
        q.pop();

        
        str[t] = false;

        //遍历t的出边(查找有没有较小路径) //只有我变小,后面的节点才能跟着变小
        for(int i = h[t] ; i != -1 ; i = ne[i]){
           int j = val[i];
            //在Bellman算法中只会更新一次小边,在此进行优化,如果能更新就把 此点(j) 放进队列中
           if(dist[j] > dist[t] + w[i]){
               dist[j] = dist[t] + w[i];
               //检查先前有没有被走过
               if(!str[j]){
                   q.push(j);
                   str[j] = true;
               }
           }
        }
    }

    if(dist[n] == 0x3f3f3f3f)cout << "impossible" << endl;
    else cout << dist[n] << endl;
}

int main()
{
    memset(h,-1,sizeof h);

    cin >> n >> m;
    int a,b,c;

    for(int i = 1 ; i <= m ; i ++ ){
        cin >> a >> b >> c;
        add(a,b,c);
    }

    spfa();

    return 0;
}
```



## spfa判断负环

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你判断图中是否存在负权回路。

#### 输入格式

第一行包含整数 n 和 m。

接下来 mm 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

如果图中**存在**负权回路，则输出 `Yes`，否则输出 `No`。

#### 数据范围

1≤n≤2000,
1≤m≤10000,
图中涉及边长绝对值均不超过 10000。

#### 输入样例：

```
3 3
1 2 -1
2 3 4
3 1 -4
```

#### 输出样例：

```
Yes
```



```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N = 1e5 + 10;

int n,m;
int h[N] , ne[N] , val[N] , w[N] , idx;
int dist[N] , cnt[N];//多个边数记录器
bool str[N];

void add(int a,int b, int c){
    val[idx] = b , w[idx] = c , ne[idx] = h[a] , h[a] = idx ++ ;
}

bool spfa(){

    queue<int>q;
    for(int i = 1 ; i <= n ; i ++ ){
        str[i] = true;
        q.push(i);
    }

    while(q.size()){
        int t = q.front();
        q.pop();

        str[t] = false;

        for(int i = h[t] ; i != -1 ; i = ne[i]){
           int j = val[i];
           if(dist[j] > dist[t] + w[i]){
               dist[j] = dist[t] + w[i];       
               cnt[j] = cnt[t] + 1;
               //如果 从 1 到 J 有n条边 那则说明 从1到J有n+1个点(但至多有n个点) 那则说明其中必有重复点构成环
               if(cnt[j] >= n){
                   return true;
               }
               if(!str[j]){
                   q.push(j);
                   str[j] = true;
               }
           }
        }
    }
    return false;
}

int main()
{
    memset(h,-1,sizeof h);

    cin >> n >> m;
    int a,b,c;

    for(int i = 1 ; i <= m ; i ++ ){
        cin >> a >> b >> c;
        add(a,b,c);
    }

    if(spfa())cout << "Yes";
    else cout << "No";

    return 0;
}
```



# Flody

$$
时间复杂度O(n^3)
$$



## Floyd求最短路

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定 kk 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 `impossible`。

数据保证图中不存在负权回路。

#### 输入格式

第一行包含三个整数 n,m,k。

接下来 mm 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

接下来 kk 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。

#### 输出格式

共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 `impossible`。

#### 数据范围

1≤n≤200
1≤k≤n2
1≤m≤20000
图中涉及边长绝对值均不超过 10000。

#### 输入样例：

```
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
```

#### 输出样例：

```
impossible
1
```



```c++
#include<iostream>
using namespace std;
const int N = 210;

int n,m,q;
int dist[N][N] , f[N][N];

void Floyd(){
    for(int i = 1 ; i <= n ; i ++ ){
        for(int j = 1 ; j <= n ; j ++ ){
            for(int k = 1 ; k <= n ; k ++ ){
                //i为中转点
                dist[j][k] = min(dist[j][k],dist[j][i] + dist[i][k]);
            }
        }
    }
}

int main()
{
    cin >> n >> m >> q;
    for(int i = 1 ; i <= n ; i ++ )
        for(int j = 1 ; j <= n ; j ++ )
            if(i != j)dist[i][j] = 1e9;

    int a,b,c;
    for(int i = 1 ; i <= m ; i ++ ){
        cin >> a >> b >> c;
        dist[a][b] = min(dist[a][b],c);
    }

    Floyd();
    
    while(q -- ){
        cin >> a >> b;
        if(dist[a][b] > 1e9 / 2)cout << "impossible" << endl;
        else cout << dist[a][b] << endl;
    }


    return 0;
}
```



# Prime

![image-20241211183730531](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241211183730531.png)

[了解-浅显易懂](【图-最小生成树-Prim(普里姆)算法和Kruskal(克鲁斯卡尔)算法】https://www.bilibili.com/video/BV1wG411z79G?vd_source=d822d177348c71c285e07dfb31013776)



## Prim算法求最小生成树

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。

由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 mm 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。

#### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

#### 数据范围

1≤n≤500
1≤m≤105,
图中涉及边的边权的绝对值均不超过 10000。

#### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

#### 输出样例：

```
6
```



```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N = 510 , INF = 0x3f3f3f3f;

int n,m;
int g[N][N];
int dist[N];
bool st[N];

int prim()
{
    memset(dist,0x3f,sizeof dist);

    int res = 0;
    //n次迭代,每一轮迭代找一个不在最小生成树中的点,然后用这个点 更新其他所有点到集合的距离,然后把该点加入集合中
    for(int i = 1 ; i <= n ; i ++ ){
        int t = -1;
        for(int j = 1 ; j <= n ; j ++ ){
            if(!st[j] && (t == -1 || dist[t] > dist[j]))t = j;
        }
        
        if(i && dist[t] == INF)return INF;
        if(i)res += dist[t];
        
        for(int j = 1 ; j <= n ; j ++ )dist[j] = min(dist[j],g[t][j]);
        
        st[t] = true;
    }

    return res;
}

int main()
{
    cin >> n >> m;

    memset(g,0x3f,sizeof g);

    while(m -- ){
        int a,b,c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b],c);
    }

    int t = prim();

    if(t == INF)cout << "impossible" << endl;
    else cout << t << endl;

    return 0;
}
```



# Kruskal

## Kruskal算法求最小生成树

给定一个 nn 个点 mm 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)G=(V,E)，其中 VV 表示图中点的集合，EE 表示图中边的集合，n=|V|n=|V|，m=|E|m=|E|。

由 VV 中的全部 nn 个顶点和 EE 中 n−1n−1 条边构成的无向连通子图被称为 GG 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 GG 的最小生成树。

#### 输入格式

第一行包含两个整数 nn 和 mm。

接下来 mm 行，每行包含三个整数 u,v,wu,v,w，表示点 uu 和点 vv 之间存在一条权值为 ww 的边。

#### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

#### 数据范围

1≤n≤1051≤n≤105,
1≤m≤2∗1051≤m≤2∗105,
图中涉及边的边权的绝对值均不超过 10001000。

#### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

#### 输出样例：

```
6
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1e5 + 10 , M = 2 * N;

int n,m;
int root[N];
int num[N];

struct pp{
    int go;
    int to;
    int l;
}pp[M];

bool cmp(struct pp p1 , struct pp p2){
    return p1.l < p2.l;
}

int find(int x){
    if(root[x] != x)root[x] = find(root[x]);
    return root[x];
}

int Kruskal()
{
    int res = 0;
    for(int i = 0 ; i < m ; i ++ ){
        int sta = pp[i].go;
        int end = pp[i].to;
        int x = find(sta);
        int y = find(end);
        if(x != y){
            root[y] = x;
            num[x] += num[y];
            res += pp[i].l;
        }
        else continue;
        if(num[x] == n)return res;
    }
    return -1;
}

int main()
{
    cin >> n >> m;

    for(int i = 1 ; i <= n ; i ++ )root[i] = i , num[i] = 1;

    for(int i = 0 ; i < m ; i ++ ){
        cin >> pp[i].go >> pp[i].to >> pp[i].l;
    }

    sort(pp , pp + m ,cmp);

    int t = Kruskal();

    if(t == -1)cout << "impossible" << endl;
    else cout << t << endl;

    return 0;
}
```



# 染色法判定二分图

## 二分图

![image-20241212204458114](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241212204458114.png)



给定一个 nn 个点 mm 条边的无向图，图中可能存在重边和自环。

请你判断这个图是否是二分图。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。

#### 输出格式

如果给定图是二分图，则输出 `Yes`，否则输出 `No`。

#### 数据范围

1≤n,m≤105

#### 输入样例：

```
4 4
1 3
1 4
2 3
2 4
```

#### 输出样例：

```
Yes
```



```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=100010,M=200010;

int n,m;
int h[N],e[M],ne[M],idx;
int color[N];//标记每个点的颜色(0表示未染色),color[i]=0,1,...

void add(int a,int b){
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

bool dfs(int u,int c){
    color[u]=c;//点u染c色

    //遍历u的所有邻接点j
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];

        //j未染色
        if(!color[j]){
            //从j开始深度优先遍历图,逐个染色
            if(!dfs(j,3-c)) return false;
        }
        //j已染色
        else if(color[j]==c) return false;//出现奇数环导致j与i同色
    }

    return true;
}

int main(){
    scanf("%d%d",&n,&m);

    //建立邻接表
    memset(h,-1,sizeof h);
    while(m--){
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b),add(b,a);
    }

    //染色法
    bool flag=true;
    //考虑到非连通图的情况,保证遍历到每一个点
    for(int i=1;i<=n;i++){
        if(!color[i]){//若i未染色
            if(!dfs(i,1)){//从i开始深度优先遍历图,逐个染色
                flag=false;//出现矛盾,染色失败
                break;
            }
        }
    }

    if(flag) puts("Yes");
    else puts("No");

    return 0;
}
```



# 匈牙利算法

## 二分图最大匹配

给定一个二分图，其中左半部包含 n1n1 个点（编号 1∼n1），右半部包含 n2n2 个点（编号 1∼n2），二分图共包含 m 条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图 GG，在 GG 的一个子图 MM 中，MM 的边集 {E}{E} 中的任意两条边都不依附于同一个顶点，则称 MM 是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

#### 输入格式

第一行包含三个整数 n1、 n2 和 m。

接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。

#### 输出格式

输出一个整数，表示二分图的最大匹配数。

#### 数据范围

1≤n1,n2≤500
1≤u≤n1,
1≤v≤n2,
1≤m≤105

#### 输入样例：

```
2 2 4
1 1
1 2
2 1
2 2
```

#### 输出样例：

```
2
```



```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std
;
const int N=510,M=100010
;
int
 h[N],e[M],ne[M],idx;
bool
 st[N];
int
 match[N];
int
 n1,n2,m;

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

bool find(int x)
{
    for(int i=h[x];i!=-1
;i=ne[i])
    {
        int
 j=e[i];
        if(!st[j])//如果这个女生没有被预定
        {
            st[j]=
true;//置为预定了
            if(match[j]==0||find(match[j]))//如果此时她还没有男朋友，或者她的现任有备胎，则他们就可以牵手成功
            //详细讲一下这里的递归，此时因为st[j]置为了true，那么当她的男朋友再去找新的女朋友时，就不会考虑这个已经被x预定的女朋友，而是去找备胎，完成我们的上一行的目标，这也解释了为什么每一次都要初始化为false
            {
                match[j]=x;
//j就是x的了
                return true;//返回牵手成功
            }
        }
    }
    return false
;
}

int main()
{
    memset(h,-1,sizeof
 h);
    scanf("%d%d%d"
,&n1,&n2,&m);
    while
(m--)
    {
        int
 a,b;
        scanf("%d%d"
,&a,&b);
        add(a,b);
//这里虽然是无向图，但我们是由男生去选择女生，因此只需要由男生指向女生即可
    }
    int res=0
;
    for(int i=1
;i<=n1;i++)
    {
        memset(st,false,sizeof st);//这里要每一次都初始化为false的原因是因为每一个男生都需要一个全部置为false的st数组，具体看find函数注释
        if(find(i)) res++;//如果成功，则res++
    }
    printf("%d\n"
,res);
}
```



# 质数

## 试除法判定质数

给定 nn 个正整数 aiai，判定每个数是否是质数。

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个正整数 aiai。

#### 输出格式

共 nn 行，其中第 ii 行输出第 ii 个正整数 aiai 是否为质数，是则输出 `Yes`，否则输出 `No`。

#### 数据范围

1≤n≤1001≤n≤100,
1≤ai≤231−11≤ai≤231−1

#### 输入样例：

```
2
2
6
```

#### 输出样例：

```
Yes
No
```



```c++
#include<iostream>
using namespace std;

void isprime(long long x){
    if(x == 1){
        cout << "No" << endl;
        return;
    }
    for(long long i = 2 ; i * i <= x ; i ++ ){
        if(x % i == 0){
            cout << "No" << endl;
            return;
        }
    }
    cout << "Yes" << endl;
}

int main()
{
    int n;
    cin >> n;
    for(int i = 1; i <= n ; i ++ ){
        long long x;
        cin >> x;
        isprime(x);
    }
    
    return 0;
}
```



## 分解质因数

给定 nn 个正整数 aiai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个正整数 aiai。

#### 输出格式

对于每个正整数 aiai，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。

每个正整数的质因数全部输出完毕后，输出一个空行。

#### 数据范围

1≤n≤1001≤n≤100,
2≤ai≤2×1092≤ai≤2×109

#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
2 1
3 1

2 3
```



```c++
#include<iostream>
using namespace std;

void div(int x){
    for(int i = 2 ; i * i <= x ; i ++ ){
        if(x % i == 0){
            int sum = 0;
            int p = x;
            while(x % i == 0){
                x /= i;
                sum ++ ;
            }
            cout << i << ' ' << sum << endl;
        }
    }
    if(x > 1)cout << x << ' ' << 1 << endl;
    cout << endl;
}

int main()
{
    int n;
    cin >> n;
    while( n -- ){
        int x;
        cin >> x;
        div(x);
    }
    
    
    
    return 0;
}
```



## 筛质数 

给定一个正整数 nn，请你求出 1∼n1∼n 中质数的个数。

#### 输入格式

共一行，包含整数 nn。

#### 输出格式

共一行，包含一个整数，表示 1∼n1∼n 中质数的个数。

#### 数据范围

1≤n≤1061≤n≤106

#### 输入样例：

```
8
```

#### 输出样例：

```
4
```



```c++
#include<iostream>
using namespace std;
const int N = 1e6 + 10;

int prime[N] , cnt;
bool st[N];

void isprime(int x){
    for(int i = 2 ; i <= x ; i ++ ){
        if(st[i])continue;
        prime[cnt ++ ] = i;
        for(int j = i + i ; j <= x ; j += i)st[j] = true;
    }
}

int main()
{
    int n ;
    cin >> n;

    isprime(n);

    cout << cnt << endl;

    return 0;
}
```



# 约数

## 试除法求约数

给定 nn 个正整数 aiai，对于每个整数 aiai，请你按照从小到大的顺序输出它的所有约数。

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个整数 aiai。

#### 输出格式

输出共 nn 行，其中第 ii 行输出第 ii 个整数 aiai 的所有约数。

#### 数据范围

1≤n≤1001≤n≤100,
1≤ai≤2×1091≤ai≤2×109

#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
1 2 3 6 
1 2 4 8 
```



```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> div(int x){
    vector<int>res;
    for(int i = 1 ; i * i <= x ; i ++ ){
        if(x % i == 0){
            res.push_back(i);
            if(i * i != x)res.push_back(x / i);
        }
    }
    sort(res.begin(),res.end());
    return res;
}

int main()
{
    int n;
    cin >> n;
    while(n -- ){
        int x;
        cin >> x;
        auto res = div(x);
        
        for(auto x : res)cout << x << ' ';
        
        cout << endl;
    }
    
    return 0;
}
```



## 约数个数

给定 nn 个正整数 aiai，请你输出这些数的乘积的约数个数，答案对 109+7109+7 取模。

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个整数 aiai。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数个数，答案需对 109+7109+7 取模。

#### 数据范围

1≤n≤1001≤n≤100,
1≤ai≤2×1091≤ai≤2×109

#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
12
```



```c++
#include<iostream>
#include<unordered_map>
using namespace std;
typedef long long ll;
const int N = 110 , mod = 1e9 + 7;

int main()
{
	int n;
    cin >> n;
    unordered_map<int,int>mp;
    while(n -- ){
        int x;
        cin >> x;
        for(int i = 2 ; i * i <= x ; i ++ ){
            while(x % i == 0){
                x /= i;
                mp[i] ++ ;
            }
        }
        if(x > 1)mp[x] ++ ;
    }
    ll res = 1;
	for(auto p : mp)res = res * (p.second + 1) % mod;

    cout << res << endl;

	return 0;
}
```



## 约数之和

给定 nn 个正整数 aiai，请你输出这些数的乘积的约数之和，答案对 109+7109+7 取模。

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个整数 aiai。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数之和，答案需对 109+7109+7 取模。

#### 数据范围

1≤n≤1001≤n≤100,
1≤ai≤2×1091≤ai≤2×109

#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
252
```



```c++
#include<iostream>
#include<unordered_map>
using namespace std;
typedef long long ll;
const int N = 110 , mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;
    unordered_map<int,int>mp(N);
    while(n -- ){
        int x;
        cin >> x;
        for(int i = 2 ; i * i <= x ; i ++ ){
            while(x % i == 0){
                x /= i;
                mp[i] ++ ;
            }
        }
        if(x > 1)mp[x] ++ ;
    }
    ll res = 1;
    for(auto p : mp){
        ll t = 1;
        int pt = p.first , a = p.second;
        while(a -- ) t = (t * pt + 1) % mod;
        res = res * t % mod;
    }
    cout << res << endl;

    return 0;
}
```



![image-20250202235556967](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20250202235556967.png)



## 最大公约数

给定 nn 对正整数 ai,biai,bi，请你求出每对数的最大公约数。

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个整数对 ai,biai,bi。

#### 输出格式

输出共 nn 行，每行输出一个整数对的最大公约数。

#### 数据范围

1≤n≤1051≤n≤105,
1≤ai,bi≤2×1091≤ai,bi≤2×109

#### 输入样例：

```
2
3 6
4 6
```

#### 输出样例：

```
3
2
```



```c++
#include<iostream>
using namespace std;

int gcd(int a,int b){
    while(a != b){
        if(a > b)a -= b;
        else b -= a;
    }
    return a;
}

int main()
{
    int n;
    cin >> n;
    while(n -- ){
        int a,b;
        cin >> a >> b;
        cout << gcd(a,b) << endl;
    }
    
    return 0;
}
```



# 欧拉

## 欧拉函数

给定 nn 个正整数 aiai，请你求出每个数的欧拉函数。

##### 欧拉函数的定义

> 1∼N1∼N 中与 NN 互质的数的个数被称为欧拉函数，记为 ϕ(N)ϕ(N)。
> 若在算数基本定理中，N=pa11pa22…pammN=p1a1p2a2…pmam，则：
> ϕ(N)ϕ(N) = N×p1−1p1×p2−1p2×…×pm−1pmN×p1−1p1×p2−1p2×…×pm−1pm

#### 输入格式

第一行包含整数 nn。

接下来 nn 行，每行包含一个正整数 aiai。

#### 输出格式

输出共 nn 行，每行输出一个正整数 aiai 的欧拉函数。

#### 数据范围

1≤n≤1001≤n≤100,
1≤ai≤2×1091≤ai≤2×109

#### 输入样例：

```
3
3
6
8
```

#### 输出样例：

```
2
2
4
```



```c++
#include<iostream>
using namespace std;

void div(int x){
    int res = x;
    for(int i = 2 ; i * i <= x ; i ++ ){
        if(x % i == 0){
            res = res / i * (i - 1);
            while(x % i == 0)x /= i;
        }
    }
    if(x > 1)res = res / x * (x - 1);
    
    cout << res << endl;
}


int main()
{
    int n;
    cin >> n;
    while(n -- ){
        int x;
        cin >> x;
        div(x);
    }
    
    return 0;
}
```



# 背包问题（DP动态规划）

## 简单背包问题

有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。

第 ii 件物品的体积是 vivi，价值是 wiwi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤10000<N,V≤1000
0<vi,wi≤10000<vi,wi≤1000

#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
8
```



```c++
#include<iostream>
using namespace std;
const int N = 1e3 + 10;

int f[N] , v[N] , w[N];

int main()
{
    int n,m;
    cin >> n >> m;

    for(int i = 1 ; i <= n ; i ++ )cin >> v[i] >> w[i];

    for(int i = 1 ; i <= n ; i++ )
        //每个f[j]代表，消耗j格背包容量所能拿到的最大价值
        for(int j = m ; j >= v[i] ; j -- )
            f[j] = max(f[j],f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```



## 完全背包问题

有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。

第 ii 种物品的体积是 vivi，价值是 wiwi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤10000<N,V≤1000
0<vi,wi≤10000<vi,wi≤1000

#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
10
```



```c++
#include<iostream>
using namespace std;
const int N = 1010;

int w[N] , v[N] , f[N];

int main()
{
    int n,m;
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i ++ )cin >> v[i] >> w[i];

    for(int i = 1 ; i <= n ; i ++ )
        //因为物品个数无限，从物品所占空间消耗容量开始 ， 
        for(int j = v[i] ; j <= m ; j ++ )
            f[j] = max(f[j],f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```



## 多重背包问题

有 NN 种物品和一个容量是 VV 的背包。

第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤1000<N,V≤100
0<vi,wi,si≤1000<vi,wi,si≤100

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```



```c++
#include<iostream>
using namespace std;
const int N = 10100;

int w[N] , v[N] , f[N] , s;

int main()
{
    int n,m;
    cin >> n >> m;
    int k = 0;
    int a,b;
    //把背包拆解出来
    for(int i = 1 ; i <= n ; i ++ ){
        cin >> a >> b >> s;
        while(s){
            v[ ++ k ] = a;
            w[k] = b;
            -- s ;
        }
    }


    for(int i = 1 ; i <= k ; i ++ )
        for(int j = m ; j >= v[i] ; j  )
            f[j] = max(f[j],f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```



## 多重背包问题 II

有 NN 种物品和一个容量是 VV 的背包。

第 ii 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V ，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N≤1000
0<V≤2000
0<vi,wi,si≤2000

##### 提示：

本题考查多重背包的二进制优化方法。

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```



```c++
#include<iostream>
using namespace std;
const int N = 2 * 1e6 + 10; //N最大1000，s最大2000 ，总共数目大致为2000000

int v[N] , w[N] , s , f[N];

int main()
{
    int n,m;
    cin >> n >> m;
    int k = 0;
    int a,b;
    for(int i = 1 ; i <= n ; i ++ ){
        int cnt = 1;
        cin >> a >> b >> s;
        //拆分优化 ， 原先背包拆分一个一个拆的做法十分冗杂，时间复杂度大致为O(n^3) , 但以二进制拆分则可以变成O(nlogs) 假如拆分7，不需要拆成一个一个1，而可以拆成1 2 4也可以表达0~7之间的数
        while(s){
           ++ k ;
           v[k] = a * cnt;
           w[k] = b * cnt;
           s -= cnt;
           if(s == 0)break;
           if(cnt * 2 <= s)cnt *= 2;
           else cnt = s;
        }
    }

    for(int i = 1 ; i <= k ; i ++ ){
        for(int j = m ; j >= v[i] ; j -- ){
            f[j] = max(f[j],f[j - v[i]] + w[i]);
        }
    }

    cout << f[m] << endl;

    return 0;
}
```



## 分组背包问题

有 NN 组物品和一个容量是 VV 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

#### 输入格式

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
- 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤100
0<Si≤100
0<vij,wij≤100

#### 输入样例

```
3 5
2
1 2
2 4
1
3 4
1
4 5
```

#### 输出样例：

```
8
```



```c++
#include<iostream>
using namespace std;
const int N = 110;

int n,m;
int f[N] , v[N] , w[N] , s;

int main()
{
    cin >> n >> m;

    for(int i = 1 ; i <= n ; i ++ ){
        cin >> s;
        //既然背包分组，那就一组一组来判断
        for(int j = 1 ; j <= s ; j ++ ) cin >> v[j] >> w[j];
        for(int j = m ; j >= 0 ; j -- ){
            //遍历决策，s+1种决策，不选这组 选第1个 选第2个 ... 选第s个
            for(int k = 1 ; k <= s ; k ++ ){
                if(j >= v[k])f[j] = max(f[j],f[j - v[k]] + w[k]);
            }
        }
    }

    cout << f[m];

    return 0;
}
```



# 线性DP

## 数字三角形

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数 nn，表示数字三角形的层数。

接下来 nn 行，每行包含若干整数，其中第 ii 行表示数字三角形第 ii 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

1≤n≤5001≤n≤500,
−10000≤三角形中的整数≤10000−10000≤三角形中的整数≤10000

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```



```c++
#include<iostream>
using namespace std;
const int N = 510;

int n ;
int dig[N][N];

int main()
{
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )
        for(int j = 1 ; j <= i ; j ++ )
            cin >> dig[i][j];
	//递推，从下往上，顶点就为递推最大答案
    for(int i = n - 1 ; i >= 1 ; i -- ){
        for(int j = 1 ; j <= i ; j ++ ){
            dig[i][j] += max(dig[i + 1][j],dig[i + 1][j + 1]);
        }
    }

    cout << dig[1][1];

    return 0;
}
```



##  最长上升子序列

给定一个长度为 NN 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 NN。

第二行包含 NN 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1≤N≤10001≤N≤1000，
−109≤数列中的数≤109−109≤数列中的数≤109

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```



```c++
#include<iostream>
using namespace std;
const int N = 1e3 + 10;

int a[N] , f[N];

int main()
{
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )cin >> a[i] , f[i] = 1;

    int ans = 0 ;
	
    //f[N]用来保存 ，以当前点为序列结尾的 序列最大长度 for example ：
    //	a： 1 2 6 5 8 7
    //	f： 1 2 3 3 4 4
    for(int i = 1 ; i <= n ; i ++ ){
        for(int j = 1 ; j < i ; j ++ ){
            //如果该数(a[i])比a[j]大，就可以把a[i]这个数接在以a[j]为结尾的序列上 , 最大长度更新为(f[j] + 1) ， 如果没有原先a[i]本身构成的序列长则不更新
            if(a[i] > a[j]){
                f[i] = max(f[j] + 1,f[i]);
            }
        }
        ans = max(f[i],ans);
    }

    cout << ans;

    return 0;
}
```



## 最长上升子序列 II

给定一个长度为 NN 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 NN。

第二行包含 NN 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1≤N≤1000001≤N≤100000，
−109≤数列中的数≤109−109≤数列中的数≤109

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```



```c++
#include<iostream>
using namespace std;
const int N = 1e5 + 10;

int a[N];
int q[N]; // q[N]的作用为存储，递增序列长度为i(q[1]为1，q[2]为2)的序列的，末位数字的最小值(序列末尾数)
int n;

int main()
{
    cin >> n;

    for(int i = 1 ; i <= n ; i ++ )cin >> a[i];

    int len = 0;

    q[1] = -2e9;
    for(int i = 1 ; i <= n ; i ++ ){
        int l = 1 , r = len + 1;
        while(l < r){
            int mid = (l + r) / 2;
            if(q[mid] >= a[i]) r = mid;
            else l = mid + 1;
        }
        len = max(len,l);
        q[l] = a[i];
    }

    cout << len << endl;

    return 0;
}
```



## 最长公共子序列

给定两个长度分别为 NN 和 MM 的字符串 AA 和 BB，求既是 AA 的子序列又是 BB 的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数 NN 和 MM。

第二行包含一个长度为 NN 的字符串，表示字符串 AA。

第三行包含一个长度为 MM 的字符串，表示字符串 BB。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1≤N,M≤10001≤N,M≤1000

#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
3
```



```c++
#include<iostream>
using namespace std;
const int N = 1e3 + 10;

char a[N] , b[N];
int x,y;
int f[N][N];

int main()
{
    cin >> x >> y;
    scanf("%s %s",a + 1,b + 1);

    for(int i = 1 ; i <= x ; i ++ ){
        for(int j = 1; j <= y ; j ++ ){
            f[i][j] = max(f[i - 1][j],f[i][j - 1]);
            if(a[i] == b[j])f[i][j] = max(f[i][j],f[i - 1][j - 1] + 1);
        }
    }

    cout << f[x][y];

    return 0;
}
```



## 最短编辑距离

给定两个字符串 AA 和 BB，现在要将 AA 经过若干操作变为 BB，可进行的操作有：

1. 删除–将字符串 AA 中的某个字符删除。
2. 插入–在字符串 AA 的某个位置插入某个字符。
3. 替换–将字符串 AA 中的某个字符替换为另一个字符。

现在请你求出，将 AA 变为 BB 至少需要进行多少次操作。

#### 输入格式

第一行包含整数 nn，表示字符串 AA 的长度。

第二行包含一个长度为 nn 的字符串 AA。

第三行包含整数 mm，表示字符串 BB 的长度。

第四行包含一个长度为 mm 的字符串 BB。

字符串中均只包含大小写字母。

#### 输出格式

输出一个整数，表示最少操作次数。

#### 数据范围

1≤n,m≤10001≤n,m≤1000

#### 输入样例：

```
10
AGTCTGACGC
11
AGTAAGTAGGC
```

#### 输出样例：

```
4
```



```c++
#include<iostream>
using namespace std;
const int N = 1e4 + 10;

char s1[N],s2[N];
int f[N][N];

int main()
{
    int n,m;
    cin >> n;
    scanf("%s %d %s",s1 + 1,&m,s2 + 1);

    for(int i = 0 ; i <= m ; i ++ ) f[0][i] = i;
    for(int i = 0 ; i <= n ; i ++ ) f[i][0] = i;

    for(int i = 1 ; i <= n ; i ++ ){
        for(int j = 1 ; j <= m ; j ++ ){
            f[i][j] = min(f[i - 1][j] + 1,f[i][j - 1] + 1);
           	f[i][j] = min(f[i][j],f[i - 1][j - 1] + (s1[i] != s2[j]))
        }
    }

    cout << f[n][m] << endl;
    

    return 0;
}
```



![image-20241227213808421](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241227213808421.png)

------

![image-20241227215002790](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241227215002790.png)

------

![image-20241227215109743](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241227215109743.png)

------



## 编辑距离

给定 nn 个长度不超过 1010 的字符串以及 mm 次询问，每次询问给出一个字符串和一个操作次数上限。

对于每次询问，请你求出给定的 nn 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。

每个对字符串进行的单个字符的插入、删除或替换算作一次操作。

#### 输入格式

第一行包含两个整数 nn 和 mm。

接下来 nn 行，每行包含一个字符串，表示给定的字符串。

再接下来 mm 行，每行包含一个字符串和一个整数，表示一次询问。

字符串中只包含小写字母，且长度均不超过 1010。

#### 输出格式

输出共 mm 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。

#### 数据范围

1≤n,m≤10001≤n,m≤1000,

#### 输入样例：

```
3 2
abc
acd
bcd
ab 1
acbd 2
```

#### 输出样例：

```
1
3
```



```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N = 15 , M = 1e3 + 10;

int n,m;
int f[N][N];
char str[M][N];

int edit(char a[],char b[]){
    int la = strlen(a + 1) , lb = strlen(b + 1);

    for(int i = 0 ; i <= lb ; i ++ ) f[0][i] = i;
    for(int i = 0 ; i <= la ; i ++ ) f[i][0] = i;

    for(int i = 1 ; i <= la ; i++ ){
        for(int j = 1 ; j <= lb ; j ++ ){
            f[i][j] = min(f[i - 1][j] + 1 , f[i][j - 1] + 1);
            f[i][j] = min(f[i][j] , f[i - 1][j - 1] + (a[i] != b[j]));
        }
    }

    return f[la][lb];
}


int main()
{
    cin >> n >> m;
    for(int i = 0 ; i < n ; i ++ )scanf("%s",str[i] + 1);

    while(m -- ){
        char s[N];
        int limit;
        scanf("%s",s + 1);
        cin >> limit;

        int res = 0;
        for(int i = 0 ; i < n ; i ++ ){
            if(edit(str[i],s) <= limit)res ++ ;
        }

        cout << res << endl;

    }


    return 0;
}
```



# 区间DP

## 石子合并

设有 NN 堆石子排成一排，其编号为 1,2,3,…,N1,2,3,…,N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 NN 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 44 堆石子分别为 `1 3 5 2`， 我们可以先合并 1、21、2 堆，代价为 44，得到 `4 5 2`， 又合并 1、21、2 堆，代价为 99，得到 `9 2` ，再合并得到 1111，总代价为 4+9+11=244+9+11=24；

如果第二步是先合并 2、32、3 堆，则代价为 77，得到 `4 7`，最后一次合并代价为 1111，总代价为 4+7+11=224+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

#### 输入格式

第一行一个数 NN 表示石子的堆数 NN。

第二行 NN 个数，表示每堆石子的质量(均不超过 10001000)。

#### 输出格式

输出一个整数，表示最小代价。

#### 数据范围

1≤N≤3001≤N≤300

#### 输入样例：

```
4
1 3 5 2
```

#### 输出样例：

```
22
```



```c++
#include<iostream>
using namespace std;
const int N = 310;

int n;
int s[N];
int f[N][N];

int main()
{
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ ){
        cin >> s[i];
        s[i] += s[i - 1];
    }
    //区间DP ， 以区间长度开算
    for(int len = 2 ; len <= n ; len ++ ){
        //枚举左端点
        for(int l = 1 ; l + len - 1 <= n ; l ++ ){
            //求出右端点
            int r = l + len - 1;
            f[l][r] = 1e8;
            //查询[l,r]最小值
            for(int k = l ; k < r ; k ++ ){
                //[l,k] + [k + 1,r] 
                f[l][r] = min(f[l][r] , f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
            }
        }
    }
    
    cout << f[1][n] << endl;
    
    return 0;
}
```



# 计数类DP

## 整数划分

一个正整数 nn 可以表示成若干个正整数之和，形如：n=n1+n2+…+nkn=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数 nn 的一种划分。

现在给定一个正整数 nn，请你求出 nn 共有多少种不同的划分方法。

#### 输入格式

共一行，包含一个整数 nn。

#### 输出格式

共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 109+7109+7 取模。

#### 数据范围

1≤n≤10001≤n≤1000

#### 输入样例:

```
5
```

#### 输出样例：

```
7
```



![image-20250110221907675](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20250110221907675.png)



```c++
#include<iostream>
using namespace std;
const int N = 1e3 +10 , mod = 1e9 + 7;

int f[N][N];

int main()
{
    int n;
    cin >> n;

    f[1][1] = 1;

    for(int i = 2 ; i <= n ; i ++ ){
        for(int j = 1 ; j <= i ; j ++ ){
            f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;
        }
    }

    int ans = 0;
    for(int i = 1 ; i <= n ; i ++ )ans = (ans + f[n][i]) % mod;

    cout << ans << endl;


    return 0;
}

//背包写法
#include<iostream>
using namespace std;
const int N = 1e3 +10 , mod = 1e9 + 7;

int f[N];

int main()
{
    int n;
    cin >> n;

    f[0] = 1;
    for(int i = 1 ; i <= n ; i ++ ){
        for(int j = i ; j <= n ;j ++ ){
            f[j] = (f[j] + f[j - i]) % mod;
        }
    }

    cout << f[n] << endl;

    return 0;
}
```



# 位数统计DP

## 计数问题

给定两个整数 aa 和 bb，求 aa 和 bb 之间的所有数字中 0∼90∼9 的出现次数。

例如，a=1024，b=1032a=1024，b=1032，则 aa 和 bb 之间共有 99 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 1010 次，`1` 出现 1010 次，`2` 出现 77 次，`3` 出现 33 次等等…

#### 输入格式

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 aa 和 bb。

当读入一行为 `0 0` 时，表示输入终止，且该行不作处理。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

#### 数据范围

0<a,b<1000000000<a,b<100000000

#### 输入样例：

```
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

#### 输出样例：

```
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```



```c++
#include<iostream>
#include<vector>
using namespace std;

int get(vector<int>pp,int l,int r){
    int res = 0;
    for(int i = l ; i >= r ; i -- )res = res * 10 + pp[i];
    return res;
}

int power10(int x){
    int res = 1;
    while( x -- ) res *= 10;
    return res;
}

int count(int n,int x){
    if(!n)return 0;

    vector<int>num;

    while(n){
        num.push_back(n % 10);
        n /= 10;
    }
    n = num.size();

    int res = 0;
    for(int i = n - 1 - !x ; i >= 0 ; i -- ){
        if(i < n - 1){
            res += get(num,n - 1,i + 1) * power10(i);
            if(!x)res -= power10(i);
        }

        if(num[i] == x) res += get(num,i - 1,0) + 1;
        else if(num[i] > x) res += power10(i);
    }

    return res;
}

int main()
{
    int a,b;
    while(cin >> a >> b , a){
        if(a > b)swap(a,b);
        for(int i = 0 ; i <= 9 ; i ++ )cout << count(b,i) - count(a - 1,i) << ' ';
        cout << endl;
    }

    return 0;
}
```



# 数形DP

## 没有上司的舞会

Ural 大学有 NN 名职员，编号为 1∼N1∼N。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 HiHi 给出，其中 1≤i≤N1≤i≤N。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

#### 输入格式

第一行一个整数 NN。

接下来 NN 行，第 ii 行表示 ii 号职员的快乐指数 HiHi。

接下来 N−1N−1 行，每行输入一对整数 L,KL,K，表示 KK 是 LL 的直接上司。（注意一下，后一个数是前一个数的**父节点**，不要搞反）。

#### 输出格式

输出最大的快乐指数。

#### 数据范围

1≤N≤60001≤N≤6000,
−128≤Hi≤127−128≤Hi≤127

#### 输入样例：

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

#### 输出样例：

```
5
```



```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N = 6 * 1e3 + 10;

int h[N] , val[N] , ne[N] , idx;
int w[N];
int f[N][2];
bool root[N];

void add(int a,int b){
    val[idx] = b , ne[idx] = h[a] , h[a] = idx ++ ;
}

void dfs_tree(int u){
    //选择u节点,加上u节点的权值
    f[u][1] = w[u];

    for(int i = h[u] ; i != -1 ; i = ne[i]){
        int j = val[i];
        dfs_tree(j);
        //1代表不选中当前点 0代表选中当前点
        f[u][1] += f[j][0];// 选了父亲结点就不能选子结点
        f[u][0] += max(f[j][0],f[j][1]);
    }
}

int main()
{
    int n;
    cin >> n;

    for(int i = 1 ; i <= n ; i ++ )cin >> w[i];

    memset(h,-1,sizeof h);

    for(int i = 0 ; i < n - 1 ; i ++ ){
        int a,b;
        cin >> a >> b;
        add(b,a);
        root[a] = true;
    }

    int tree = 1;
    //找到整个树的根节点(tree)
    while(root[tree])tree ++ ;

    dfs_tree(tree);

    cout << max(f[tree][0],f[tree][1]);

    return 0;
}
```



# 记忆化搜索

### 对已有的答案保存下来，实现dfs树的减枝，减少递归次数



给定一个 RR 行 CC 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 ii 行第 jj 列的点表示滑雪场的第 ii 行第 jj 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 24−17−2−124−17−2−1。

在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−125−24−23−…−3−2−1，沿途共经过 2525 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

#### 输入格式

第一行包含两个整数 RR 和 CC。

接下来 RR 行，每行包含 CC 个整数，表示完整的二维矩阵。

#### 输出格式

输出一个整数，表示可完成的最长滑雪长度。

#### 数据范围

1≤R,C≤3001≤R,C≤300,
0≤矩阵中整数≤100000≤矩阵中整数≤10000

#### 输入样例：

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

#### 输出样例：

```
25
```



```c++
#include<iostream>
using namespace std;
const int N = 310;

int R,C;
int gd[N][N];
int f[N][N];

int dx[4] = {0,0,1,-1} , dy[4] = {-1,1,0,0};

int dfs(int x,int y){

    if(f[x][y])return f[x][y];

    f[x][y] = 1;

    for(int i = 0 ; i < 4 ; i ++ ){
        int x1 = x + dx[i];
        int y1 = y + dy[i];
        if(x1 >= 1 && x1 <= R && y1 >= 1 && y1 <= C && gd[x1][y1] < gd[x][y]){
            f[x][y] = max(f[x][y],dfs(x1,y1) + 1);
        }
    }

    return f[x][y];
}

int main()
{
    cin >> R >> C;

    for(int i = 1 ; i <= R ; i ++ )
        for(int j = 1 ; j <= C ; j ++ )
            cin >> gd[i][j];

    int res = 0;

    for(int i = 1 ; i <= R ; i ++ )
        for(int j = 1 ; j <= C ; j ++ )
            res = max(res,dfs(i,j));

    cout << res;

    return 0;
}
```





# 贪心

## 1.贪心的策略是每次步骤选择当下最优解，认为得出的结果就是最优的，有种短视不顾长远的感觉

## 2.找到符合题意的逻辑，按1进行

[删数问题（贪心算法）-CSDN博客](https://blog.csdn.net/ACMerdsb/article/details/108500313)

# 区间问题

## 1.区间选点

给定 N 个闭区间 [ai,bi][ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示所需的点的最小数量。

#### 数据范围

1≤N≤105,
−109≤ai≤bi≤109，

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
typedef pair<int,int>pp;
const int N = 1e5 + 10;

pp inter[N];

int main()
{
    int n;
    cin >> n;

    for(int i = 1 ; i <= n ; i ++ )cin >> inter[i].first >> inter[i].second;
    sort(inter + 1,inter + n + 1);

    int cnt = 0;
    int head = -2e9 , tail = -2e9;
    for(int i = 1 ; i <= n ; i ++ ){
        if(inter[i].first > tail){
            cnt ++ ;
            head = inter[i].first;
            tail = inter[i].second;
        }
        else {
            head = max(head,inter[i].first);
            tail = min(tail,inter[i].second);
        }
    }

    cout << cnt;

    return 0;
}
```



## 2.最大不相交区间数量

给定 N 个闭区间 [ai,bi] 请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。

输出可选取区间的最大数量。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示可选取区间的最大数量。

#### 数据范围

1≤N≤105,
−109≤ai≤bi≤109

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```



```c++
//法一
#include<iostream>
#include<algorithm>
using namespace std;
typedef pair<int,int>pp;
const int N = 1e5 + 10;

pp op[N];
bool cmp(pp p1,pp p2){
    return p1.second < p2.second;
}

int main()
{
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )cin >> op[i].first >> op[i].second;

    int tail = -2e9 , cnt = 0;
    sort(op + 1 , op + 1 + n , cmp);

    for(int i = 1 ; i <= n ; i ++ ){
        if(tail < op[i].first){
            cnt ++ ;
            tail = op[i].second;
        }
    }

    cout << cnt << endl;

    return 0;
}

//法二
#include<iostream>
#include<algorithm>
const int N = 1e5 + 10;

struct pp{
    int l;
    int r;
    //重载运算符
    bool operato< (const pp &w)const
    {
        return r < w.r;
    }
}

int main()
{
    int n ;
    cin >> n;
    
   	for(int i = 1 ; i <= n ; i ++ )cin >> pp[i].l >> pp[i].r;
    
    sort(pp + 1 , pp + 1 + n);
    
   	int cnt = 0 , tail = -2e9; 
   
    for(int i = 1 ; i <= n ; i ++ ){
        if(tail < pp[i].l){
            cnt ++ ;
            tail = pp[i].r;
        }
    }
    
    return 0;
}
```



## 3.区间分组

给定 N 个闭区间 [ai,bi][ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示最小组数。

#### 数据范围

1≤N≤105,
−109≤ai≤bi≤109

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```



```c++
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int N = 1e5 + 10;

struct pp{
    int l,r;
    bool operator< (const pp &w)const
    {
        return l < w.l;
    }
}pp[N];

int main()
{
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )cin >> pp[i].l >> pp[i].r;
    sort(pp + 1 , pp + 1 + n);

    priority_queue<int,vector<int>,greater<>>p;
    for(int i = 1 ; i <= n ; i ++ ){
        auto t = pp[i];
        //如果当前没有分组 或是 组中的最小区间的最大右区间端点 >= 当前区间左端点(说明有交集) 新开一组
        if(p.empty() || p.top() >= t.l)p.push(t.r);
        //如果没有 , 就加入原先的一个组中 , 更新组内右区间端点最大值
        else {
            p.pop();
            p.push(t.r);
        }
    }

    cout << p.size();

    return 0;
}
```



## 4.区间覆盖

给定 N 个区间 [ai,bi][ai,bi] 以及一个区间 [s,t][s,t]，请你选择尽量少的区间，将指定区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

#### 输入格式

第一行包含两个整数 s 和 t，表示给定区间的两个端点。

第二行包含整数 N，表示给定区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示所需最少区间数。

如果无解，则输出 −1。

#### 数据范围

1≤N≤105,
−109≤ai≤bi≤109,
−109≤s≤t≤109

#### 输入样例：

```
1 5
3
-1 3
2 4
3 5
```

#### 输出样例：

```
2
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1e5 + 10;

struct pp{
    int l,r;
    bool operator< (const pp &w)const
    {
        return l < w.l;
    }
}pp[N];

int main()
{
    int n , sta , end;
    cin >> sta >> end;
    cin >> n ;
    for(int i = 1 ; i <= n ;  i ++ )cin >> pp[i].l >> pp[i].r;

    sort(pp + 1 , pp + 1 + n);

    int ans = 0;
    bool isall = false;
    for(int i = 1 ; i <= n ; i ++ ){
        int j = i , r = -2e9;
        //如果有区间就接着往后找覆盖 直到找到可以覆盖 目标区间起点 的区间
        while(j <= n && pp[j].l <= sta){
            //更新覆盖区间往后的 右区间端点
            r = max(r,pp[j].r);
            j ++ ;
        }
        //如果更新完所有点后右区间端点小于 目标区间起点 则说明不可能覆盖完
        if(r < sta){
            break;
        }
        //找到一个区间 可以覆盖目标起点时 断出循环
        ans ++ ;
        //覆盖完成
        if(r >= end){
            isall = true;
            break;
        }
        //重新更新 目标区间起点 为可以覆盖目标区间起点的区间的右端点
        sta = r;
        //更新i
        i = j - 1;
    }

    if(!isall)ans = -1;
    cout << ans;

    return 0;
}
```



# Huffman树

## 1.合并果子

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 33 种果子，数目依次为 1，2，9。

可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力=3+12=15。

可以证明 15 为最小的体力耗费值。

#### 输入格式

输入包括两行，第一行是一个整数 n，表示果子的种类数。

第二行包含 n 个整数，用空格分隔，第 i 个整数 ai 是第 i 种果子的数目。

#### 输出格式

输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。

输入数据保证这个值小于 231。

#### 数据范围

1≤n≤10000,
1≤ai≤20000

#### 输入样例：

```
3 
1 2 9 
```

#### 输出样例：

```
15
```



```c++
#include<iostream>
#include<queue>
#include<vector>
using namespace std;

priority_queue<int,vector<int>,greater<int>>heap;

int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 0 ; i < n ; i ++ ){
        int x;
        scanf("%d",&x);
        heap.push(x);
    }

    int res = 0;

    while(heap.size() > 1){
        int a = heap.top();
        heap.pop();
        int b = heap.top();
        heap.pop();
        res += a + b;
        heap.push(a + b);
    }

    printf("%d",res);

    return 0;
}
```



# 排序不等式

## 1.排队打水

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 ti。

#### 输出格式

输出一个整数，表示最小的等待时间之和。

#### 数据范围

1≤n≤105,
1≤ti≤104

#### 输入样例：

```
7
3 6 1 4 2 5 7
```

#### 输出样例：

```
56
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1e5 + 10;

long long a[N];

int main()
{
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )cin >> a[i];
    sort(a + 1 , a + 1 + n);

    long long sum = 0;
    for(int i = 1 ; i <= n ; i ++ ){
        sum += a[i - 1];
        a[i] += a[i - 1];
    }

    cout << sum;

    return 0;
}
```



# 绝对值不等式

## 1.货仓选址

在一条数轴上有 *N* 家商店，它们的坐标分别为 *A*1∼AN。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

#### 输入格式

第一行输入整数 *N*。

第二行 *N* 个整数 *A*1∼*AN*。

#### 输出格式

输出一个整数，表示距离之和的最小值。

#### 数据范围

1≤*N*≤100000,
0≤*Ai*≤40000

#### 输入样例：

```
4
6 2 9 1
```

#### 输出样例：

```
12
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1e5 + 10;

int a[N];

int main()
{
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ )cin >> a[i];

    sort(a + 1 , a + 1 + n);

    int l = 0;
    for(int i = 1 ; i <= n / 2 ; i ++ ){
        l += a[n + 1 - i] - a[i];
    }

    cout << l << endl;

    return 0;
}
```



# 推公式

## 1.耍杂技的牛

 农民约翰的 N 头奶牛（编号为 1....N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

#### 输入格式

第一行输入整数 N，表示奶牛数量。

接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 ii 行表示第 ii 头牛的重量 Wi 以及它的强壮程度 Si。

#### 输出格式

输出一个整数，表示最大风险值的最小可能值。

#### 数据范围

1≤N≤50000,
1≤Wi≤10,000,
1≤Si≤1,000,000,000

#### 输入样例：

```
3
10 3
2 5
3 3
```

#### 输出样例：

```
2
```



![image-20241222173147997](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241222173147997.png)



![image-20241222173250763](C:\Users\30959\AppData\Roaming\Typora\typora-user-images\image-20241222173250763.png)





```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 5 * 1e4 + 10;
typedef pair<int,int>pp;

pp cow[N];

int main()
{
    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i ++ ){
        int w,s;
        cin >> w >> s;
        cow[i] = {w + s,w};
    }

    sort(cow + 1 , cow + 1 + n);

    int sum = 0 , res = -2e9;
    for(int i = 1 ; i <= n ; i ++ ){
        int s = cow[i].first - cow[i].second;
        int w = cow[i].second;
        //最大危险系数(头上牛的重量减去自身的强壮度)
        res = max(res,sum - s);
        //头上牛的重量
        sum += w;
    }

    cout << res << endl;

    return 0;
}
```



## [搜索](https://ac.nowcoder.com/acm/contest/95336/B)

```c++
#include<iostream>
using namespace std;
const int mod = 1e9 + 7;



void gres(string t,int &s_01,int &s_10){
    s_01 = 0 , s_10 = 0;
    for (int i = 0 ; i < t.length() - 1 ; i ++  ) {
        if (t[i] == '0' && t[i + 1] == '1') s_01++;
        else if (t[i] == '1' && t[i + 1] == '0')s_10++;
    }
}

int val(string a){
    int res = 0;
    for(int i = 0 ; i < a.length() ; i ++ ) {
        string t = a;
        if(t[i] == '0')t[i] = '1';
        else if(t[i] == '1')t[i] = '0';
        int s_01 = 0;
        int s_10 = 0;
        gres(t,s_01,s_10);
        if(s_01 == s_10)res ++ ;
    }
    return res;
}

void find(string &tp,int p,string a,int &ans){
    if(p == a.size()){
        ans = (ans + val(tp)) % mod;
        return;
    }
    if(a[p] == '?'){
        tp[p] = '0';
        find(tp,p + 1,a,ans);
        tp[p] = '1';
        find(tp,p + 1,a,ans);
    }
    else {
        tp[p] = a[p];
        find(tp, p + 1, a, ans);
    }
}

int main()
{
    int T;
    cin >> T;
    while(T -- ){
        int n;
        cin >> n;
        string a;
        cin >> a;
        string tp = a;
        int ans = 0;
        find(tp,0,a,ans);
        cout << ans << endl;
    }

    return 0;
}
```



## [对角前缀map](https://ac.nowcoder.com/acm/contest/95336/E)

```c++
#include<iostream>
#include<unordered_map>
using namespace std;
const int N = 1e3 + 10 ;
typedef long long ll;

int a[N][N];

int main()
{
    int T;
    cin >> T;

    while(T -- ){
        ll ans = 0;
        int n,m;
        cin >> n >> m;
        unordered_map<int,ll>l,r;
        for(int i = 1 ; i <= n ; i ++ ){
            for(int j = 1 ; j <= m ; j ++ ){
                cin >> a[i][j];
                l[i + j] += a[i][j];
                r[i - j] += a[i][j];
            }
        }

        for(int i = 1 ; i <= n ; i ++ ){
            for(int j = 1 ; j <= m ; j ++ ){
                ans = max(ans,l[i + j] + r[i - j] - a[i][j]);
            }
        }
        cout << ans << endl;
    }

    return 0;
}
```



## [匹配子串](https://ac.nowcoder.com/acm/contest/95336/I)

```c++
#include<iostream>
#include<cstring>
using namespace std;

int main()
{
    int T;
    cin >> T;
    string st = "uwawauwa";
    while(T -- ){
        int n;
        cin >> n;
        string a;
        cin >> a;
        int k = 0;
        int cnt = 0;
        int ans = 0;
        for(int i = 0 ; i < n ; i ++ ){
            for(int j = 0 ; j < 7 ; j ++ ){
                if(a[i + j] != st[j] || i + j >= n)break;
                if(j == 6){
                    for(; k <= i - 2 ; k ++ )if(a[k] == 'u')cnt ++ ;
                    ans += cnt;
                }
            }
        }
        cout << ans << endl;
    }

    return 0;
}
```

